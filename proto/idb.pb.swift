// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/idb.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright (c) Meta Platforms, Inc. and affiliates.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Idb_Setting: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case locale // = 0

  /// any kind of app or global setting
  case any // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .locale
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .locale
    case 1: self = .any
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .locale: return 0
    case .any: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Idb_Setting] = [
    .locale,
    .any,
  ]

}

struct Idb_Payload: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: Idb_Payload.OneOf_Source? = nil

  var filePath: String {
    get {
      if case .filePath(let v)? = source {return v}
      return String()
    }
    set {source = .filePath(newValue)}
  }

  var data: Data {
    get {
      if case .data(let v)? = source {return v}
      return Data()
    }
    set {source = .data(newValue)}
  }

  var url: String {
    get {
      if case .url(let v)? = source {return v}
      return String()
    }
    set {source = .url(newValue)}
  }

  var compression: Idb_Payload.Compression {
    get {
      if case .compression(let v)? = source {return v}
      return .gzip
    }
    set {source = .compression(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Source: Equatable, @unchecked Sendable {
    case filePath(String)
    case data(Data)
    case url(String)
    case compression(Idb_Payload.Compression)

  }

  enum Compression: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case gzip // = 0
    case zstd // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .gzip
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .gzip
      case 1: self = .zstd
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .gzip: return 0
      case .zstd: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_Payload.Compression] = [
      .gzip,
      .zstd,
    ]

  }

  init() {}
}

struct Idb_ProcessOutput: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var interface: Idb_ProcessOutput.Interface = .stdout

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Interface: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case stdout // = 0
    case stderr // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .stdout
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .stdout
      case 1: self = .stderr
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .stdout: return 0
      case .stderr: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_ProcessOutput.Interface] = [
      .stdout,
      .stderr,
    ]

  }

  init() {}
}

struct Idb_CompanionInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var udid: String = String()

  var isLocal: Bool = false

  var metadata: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_SettingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var setting: Idb_SettingRequest.OneOf_Setting? = nil

  var hardwareKeyboard: Idb_SettingRequest.HardwareKeyboard {
    get {
      if case .hardwareKeyboard(let v)? = setting {return v}
      return Idb_SettingRequest.HardwareKeyboard()
    }
    set {setting = .hardwareKeyboard(newValue)}
  }

  var stringSetting: Idb_SettingRequest.StringSetting {
    get {
      if case .stringSetting(let v)? = setting {return v}
      return Idb_SettingRequest.StringSetting()
    }
    set {setting = .stringSetting(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Setting: Equatable, Sendable {
    case hardwareKeyboard(Idb_SettingRequest.HardwareKeyboard)
    case stringSetting(Idb_SettingRequest.StringSetting)

  }

  struct HardwareKeyboard: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct StringSetting: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var setting: Idb_Setting = .locale

    var value: String = String()

    /// iff setting == ANY
    var name: String = String()

    /// assumed "Apple Global Domain" if empty
    var domain: String = String()

    ///
    /// Currently supported value_types and corresponding values are:
    ///  string <string_value>
    ///  data <hex_digits>
    ///  int[eger] <integer_value>
    ///  float  <floating-point_value>
    ///  bool[ean] (true | false | yes | no)
    ///  date <date_rep>
    ///  array <value1> <value2> ...
    ///  array-add <value1> <value2> ...
    ///  dict <key1> <value1> <key2> <value2> ...
    ///  dict-add <key1> <value1> ...
    ///
    /// Check defaults set help for more details.
    var valueType: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_SettingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_GetSettingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var setting: Idb_Setting = .locale

  /// iff setting == ANY
  var name: String = String()

  /// assumed "Apple Global Domain" if empty
  var domain: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_GetSettingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_ListSettingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var setting: Idb_Setting = .locale

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_ListSettingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var values: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_ListAppsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var suppressProcessState: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_ListAppsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var apps: [Idb_InstalledAppInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_InstalledAppInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bundleID: String = String()

  var name: String = String()

  var architectures: [String] = []

  var installType: String = String()

  var processState: Idb_InstalledAppInfo.AppProcessState = .unknown

  var debuggable: Bool = false

  var processIdentifier: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum AppProcessState: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case notRunning // = 1
    case running // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .notRunning
      case 2: self = .running
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .notRunning: return 1
      case .running: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_InstalledAppInfo.AppProcessState] = [
      .unknown,
      .notRunning,
      .running,
    ]

  }

  init() {}
}

struct Idb_InstallRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Idb_InstallRequest.OneOf_Value? = nil

  var destination: Idb_InstallRequest.Destination {
    get {
      if case .destination(let v)? = value {return v}
      return .app
    }
    set {value = .destination(newValue)}
  }

  var payload: Idb_Payload {
    get {
      if case .payload(let v)? = value {return v}
      return Idb_Payload()
    }
    set {value = .payload(newValue)}
  }

  var nameHint: String {
    get {
      if case .nameHint(let v)? = value {return v}
      return String()
    }
    set {value = .nameHint(newValue)}
  }

  var makeDebuggable: Bool {
    get {
      if case .makeDebuggable(let v)? = value {return v}
      return false
    }
    set {value = .makeDebuggable(newValue)}
  }

  ///(2022-03-02) REMOVE, For back compatibility only.
  var bundleID: String {
    get {
      if case .bundleID(let v)? = value {return v}
      return String()
    }
    set {value = .bundleID(newValue)}
  }

  /// Link dSYM to app bundle_id
  var linkDsymToBundle: Idb_InstallRequest.LinkDsymToBundle {
    get {
      if case .linkDsymToBundle(let v)? = value {return v}
      return Idb_InstallRequest.LinkDsymToBundle()
    }
    set {value = .linkDsymToBundle(newValue)}
  }

  var overrideModificationTime: Bool {
    get {
      if case .overrideModificationTime(let v)? = value {return v}
      return false
    }
    set {value = .overrideModificationTime(newValue)}
  }

  var skipSigningBundles: Bool {
    get {
      if case .skipSigningBundles(let v)? = value {return v}
      return false
    }
    set {value = .skipSigningBundles(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable, Sendable {
    case destination(Idb_InstallRequest.Destination)
    case payload(Idb_Payload)
    case nameHint(String)
    case makeDebuggable(Bool)
    ///(2022-03-02) REMOVE, For back compatibility only.
    case bundleID(String)
    /// Link dSYM to app bundle_id
    case linkDsymToBundle(Idb_InstallRequest.LinkDsymToBundle)
    case overrideModificationTime(Bool)
    case skipSigningBundles(Bool)

  }

  enum Destination: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case app // = 0
    case xctest // = 1
    case dylib // = 2
    case dsym // = 3
    case framework // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .app
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .app
      case 1: self = .xctest
      case 2: self = .dylib
      case 3: self = .dsym
      case 4: self = .framework
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .app: return 0
      case .xctest: return 1
      case .dylib: return 2
      case .dsym: return 3
      case .framework: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_InstallRequest.Destination] = [
      .app,
      .xctest,
      .dylib,
      .dsym,
      .framework,
    ]

  }

  struct LinkDsymToBundle: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bundleType: Idb_InstallRequest.LinkDsymToBundle.BundleType = .app

    var bundleID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum BundleType: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case app // = 0
      case xctest // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .app
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .app
        case 1: self = .xctest
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .app: return 0
        case .xctest: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Idb_InstallRequest.LinkDsymToBundle.BundleType] = [
        .app,
        .xctest,
      ]

    }

    init() {}
  }

  init() {}
}

struct Idb_InstallResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var uuid: String = String()

  var progress: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_ScreenshotRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_ScreenshotResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imageData: Data = Data()

  var imageFormat: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_FocusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_FocusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_Point: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_AccessibilityInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var point: Idb_Point {
    get {return _point ?? Idb_Point()}
    set {_point = newValue}
  }
  /// Returns true if `point` has been explicitly set.
  var hasPoint: Bool {return self._point != nil}
  /// Clears the value of `point`. Subsequent reads from it will return its default value.
  mutating func clearPoint() {self._point = nil}

  var format: Idb_AccessibilityInfoRequest.Format = .legacy

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Format: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case legacy // = 0
    case nested // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .legacy
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .legacy
      case 1: self = .nested
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .legacy: return 0
      case .nested: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_AccessibilityInfoRequest.Format] = [
      .legacy,
      .nested,
    ]

  }

  init() {}

  fileprivate var _point: Idb_Point? = nil
}

struct Idb_AccessibilityInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var json: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_ApproveRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bundleID: String = String()

  var permissions: [Idb_ApproveRequest.Permission] = []

  var scheme: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Permission: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case photos // = 0
    case camera // = 1
    case contacts // = 2
    case url // = 3
    case location // = 4
    case notification // = 5
    case microphone // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .photos
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .photos
      case 1: self = .camera
      case 2: self = .contacts
      case 3: self = .url
      case 4: self = .location
      case 5: self = .notification
      case 6: self = .microphone
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .photos: return 0
      case .camera: return 1
      case .contacts: return 2
      case .url: return 3
      case .location: return 4
      case .notification: return 5
      case .microphone: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_ApproveRequest.Permission] = [
      .photos,
      .camera,
      .contacts,
      .url,
      .location,
      .notification,
      .microphone,
    ]

  }

  init() {}
}

struct Idb_ApproveResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_RevokeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bundleID: String = String()

  var permissions: [Idb_RevokeRequest.Permission] = []

  var scheme: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Permission: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case photos // = 0
    case camera // = 1
    case contacts // = 2
    case url // = 3
    case location // = 4
    case notification // = 5
    case microphone // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .photos
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .photos
      case 1: self = .camera
      case 2: self = .contacts
      case 3: self = .url
      case 4: self = .location
      case 5: self = .notification
      case 6: self = .microphone
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .photos: return 0
      case .camera: return 1
      case .contacts: return 2
      case .url: return 3
      case .location: return 4
      case .notification: return 5
      case .microphone: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_RevokeRequest.Permission] = [
      .photos,
      .camera,
      .contacts,
      .url,
      .location,
      .notification,
      .microphone,
    ]

  }

  init() {}
}

struct Idb_RevokeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_ClearKeychainRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_ClearKeychainResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_SetLocationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: Idb_Location {
    get {return _location ?? Idb_Location()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _location: Idb_Location? = nil
}

struct Idb_Location: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var latitude: Double = 0

  var longitude: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_SetLocationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_UninstallRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bundleID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_UninstallResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_TerminateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bundleID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_TerminateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_OpenUrlRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_OpenUrlResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_ContactsUpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Idb_Payload {
    get {return _payload ?? Idb_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Idb_Payload? = nil
}

struct Idb_ContactsUpdateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_TargetDescriptionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fetchDiagnostics: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_TargetDescriptionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targetDescription: Idb_TargetDescription {
    get {return _targetDescription ?? Idb_TargetDescription()}
    set {_targetDescription = newValue}
  }
  /// Returns true if `targetDescription` has been explicitly set.
  var hasTargetDescription: Bool {return self._targetDescription != nil}
  /// Clears the value of `targetDescription`. Subsequent reads from it will return its default value.
  mutating func clearTargetDescription() {self._targetDescription = nil}

  var companion: Idb_CompanionInfo {
    get {return _companion ?? Idb_CompanionInfo()}
    set {_companion = newValue}
  }
  /// Returns true if `companion` has been explicitly set.
  var hasCompanion: Bool {return self._companion != nil}
  /// Clears the value of `companion`. Subsequent reads from it will return its default value.
  mutating func clearCompanion() {self._companion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _targetDescription: Idb_TargetDescription? = nil
  fileprivate var _companion: Idb_CompanionInfo? = nil
}

struct Idb_HIDEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Idb_HIDEvent.OneOf_Event? = nil

  var press: Idb_HIDEvent.HIDPress {
    get {
      if case .press(let v)? = event {return v}
      return Idb_HIDEvent.HIDPress()
    }
    set {event = .press(newValue)}
  }

  var swipe: Idb_HIDEvent.HIDSwipe {
    get {
      if case .swipe(let v)? = event {return v}
      return Idb_HIDEvent.HIDSwipe()
    }
    set {event = .swipe(newValue)}
  }

  var delay: Idb_HIDEvent.HIDDelay {
    get {
      if case .delay(let v)? = event {return v}
      return Idb_HIDEvent.HIDDelay()
    }
    set {event = .delay(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable, Sendable {
    case press(Idb_HIDEvent.HIDPress)
    case swipe(Idb_HIDEvent.HIDSwipe)
    case delay(Idb_HIDEvent.HIDDelay)

  }

  enum HIDDirection: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case down // = 0
    case up // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .down
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .down
      case 1: self = .up
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .down: return 0
      case .up: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_HIDEvent.HIDDirection] = [
      .down,
      .up,
    ]

  }

  enum HIDButtonType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case applePay // = 0
    case home // = 1
    case lock // = 2
    case sideButton // = 3
    case siri // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .applePay
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .applePay
      case 1: self = .home
      case 2: self = .lock
      case 3: self = .sideButton
      case 4: self = .siri
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .applePay: return 0
      case .home: return 1
      case .lock: return 2
      case .sideButton: return 3
      case .siri: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_HIDEvent.HIDButtonType] = [
      .applePay,
      .home,
      .lock,
      .sideButton,
      .siri,
    ]

  }

  struct HIDTouch: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var point: Idb_Point {
      get {return _point ?? Idb_Point()}
      set {_point = newValue}
    }
    /// Returns true if `point` has been explicitly set.
    var hasPoint: Bool {return self._point != nil}
    /// Clears the value of `point`. Subsequent reads from it will return its default value.
    mutating func clearPoint() {self._point = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _point: Idb_Point? = nil
  }

  struct HIDButton: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var button: Idb_HIDEvent.HIDButtonType = .applePay

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct HIDKey: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var keycode: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct HIDPressAction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var action: Idb_HIDEvent.HIDPressAction.OneOf_Action? = nil

    var touch: Idb_HIDEvent.HIDTouch {
      get {
        if case .touch(let v)? = action {return v}
        return Idb_HIDEvent.HIDTouch()
      }
      set {action = .touch(newValue)}
    }

    var button: Idb_HIDEvent.HIDButton {
      get {
        if case .button(let v)? = action {return v}
        return Idb_HIDEvent.HIDButton()
      }
      set {action = .button(newValue)}
    }

    var key: Idb_HIDEvent.HIDKey {
      get {
        if case .key(let v)? = action {return v}
        return Idb_HIDEvent.HIDKey()
      }
      set {action = .key(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Action: Equatable, Sendable {
      case touch(Idb_HIDEvent.HIDTouch)
      case button(Idb_HIDEvent.HIDButton)
      case key(Idb_HIDEvent.HIDKey)

    }

    init() {}
  }

  struct HIDPress: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var action: Idb_HIDEvent.HIDPressAction {
      get {return _action ?? Idb_HIDEvent.HIDPressAction()}
      set {_action = newValue}
    }
    /// Returns true if `action` has been explicitly set.
    var hasAction: Bool {return self._action != nil}
    /// Clears the value of `action`. Subsequent reads from it will return its default value.
    mutating func clearAction() {self._action = nil}

    var direction: Idb_HIDEvent.HIDDirection = .down

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _action: Idb_HIDEvent.HIDPressAction? = nil
  }

  struct HIDSwipe: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var start: Idb_Point {
      get {return _start ?? Idb_Point()}
      set {_start = newValue}
    }
    /// Returns true if `start` has been explicitly set.
    var hasStart: Bool {return self._start != nil}
    /// Clears the value of `start`. Subsequent reads from it will return its default value.
    mutating func clearStart() {self._start = nil}

    var end: Idb_Point {
      get {return _end ?? Idb_Point()}
      set {_end = newValue}
    }
    /// Returns true if `end` has been explicitly set.
    var hasEnd: Bool {return self._end != nil}
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    mutating func clearEnd() {self._end = nil}

    var delta: Double = 0

    var duration: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _start: Idb_Point? = nil
    fileprivate var _end: Idb_Point? = nil
  }

  struct HIDDelay: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var duration: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_HIDResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_ConnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Dictionary<String,String> = [:]

  var localFilePath: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_ConnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var companion: Idb_CompanionInfo {
    get {return _companion ?? Idb_CompanionInfo()}
    set {_companion = newValue}
  }
  /// Returns true if `companion` has been explicitly set.
  var hasCompanion: Bool {return self._companion != nil}
  /// Clears the value of `companion`. Subsequent reads from it will return its default value.
  mutating func clearCompanion() {self._companion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _companion: Idb_CompanionInfo? = nil
}

struct Idb_ScreenDimensions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: UInt64 = 0

  var height: UInt64 = 0

  var density: Double = 0

  var widthPoints: UInt64 = 0

  var heightPoints: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_TargetDescription: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var udid: String = String()

  var name: String = String()

  var screenDimensions: Idb_ScreenDimensions {
    get {return _screenDimensions ?? Idb_ScreenDimensions()}
    set {_screenDimensions = newValue}
  }
  /// Returns true if `screenDimensions` has been explicitly set.
  var hasScreenDimensions: Bool {return self._screenDimensions != nil}
  /// Clears the value of `screenDimensions`. Subsequent reads from it will return its default value.
  mutating func clearScreenDimensions() {self._screenDimensions = nil}

  var state: String = String()

  var targetType: String = String()

  var osVersion: String = String()

  var architecture: String = String()

  var extended: Data = Data()

  var diagnostics: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _screenDimensions: Idb_ScreenDimensions? = nil
}

struct Idb_LogRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var arguments: [String] = []

  var source: Idb_LogRequest.Source = .target

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Source: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case target // = 0
    case companion // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .target
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .target
      case 1: self = .companion
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .target: return 0
      case .companion: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_LogRequest.Source] = [
      .target,
      .companion,
    ]

  }

  init() {}
}

struct Idb_LogResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var output: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_RecordRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var control: Idb_RecordRequest.OneOf_Control? = nil

  var start: Idb_RecordRequest.Start {
    get {
      if case .start(let v)? = control {return v}
      return Idb_RecordRequest.Start()
    }
    set {control = .start(newValue)}
  }

  var stop: Idb_RecordRequest.Stop {
    get {
      if case .stop(let v)? = control {return v}
      return Idb_RecordRequest.Stop()
    }
    set {control = .stop(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Control: Equatable, Sendable {
    case start(Idb_RecordRequest.Start)
    case stop(Idb_RecordRequest.Stop)

  }

  struct Start: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var filePath: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Stop: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_RecordResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var output: Idb_RecordResponse.OneOf_Output? = nil

  var logOutput: Data {
    get {
      if case .logOutput(let v)? = output {return v}
      return Data()
    }
    set {output = .logOutput(newValue)}
  }

  var payload: Idb_Payload {
    get {
      if case .payload(let v)? = output {return v}
      return Idb_Payload()
    }
    set {output = .payload(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Output: Equatable, @unchecked Sendable {
    case logOutput(Data)
    case payload(Idb_Payload)

  }

  init() {}
}

struct Idb_VideoStreamRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var control: Idb_VideoStreamRequest.OneOf_Control? = nil

  var start: Idb_VideoStreamRequest.Start {
    get {
      if case .start(let v)? = control {return v}
      return Idb_VideoStreamRequest.Start()
    }
    set {control = .start(newValue)}
  }

  var stop: Idb_VideoStreamRequest.Stop {
    get {
      if case .stop(let v)? = control {return v}
      return Idb_VideoStreamRequest.Stop()
    }
    set {control = .stop(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Control: Equatable, Sendable {
    case start(Idb_VideoStreamRequest.Start)
    case stop(Idb_VideoStreamRequest.Stop)

  }

  enum Format: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case h264 // = 0
    case rbga // = 1
    case mjpeg // = 2
    case minicap // = 3
    case i420 // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .h264
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .h264
      case 1: self = .rbga
      case 2: self = .mjpeg
      case 3: self = .minicap
      case 4: self = .i420
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .h264: return 0
      case .rbga: return 1
      case .mjpeg: return 2
      case .minicap: return 3
      case .i420: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_VideoStreamRequest.Format] = [
      .h264,
      .rbga,
      .mjpeg,
      .minicap,
      .i420,
    ]

  }

  struct Start: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var filePath: String = String()

    var fps: UInt64 = 0

    var format: Idb_VideoStreamRequest.Format = .h264

    var compressionQuality: Double = 0

    var scaleFactor: Double = 0

    var avgBitrate: Double = 0

    var keyFrameRate: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Stop: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_VideoStreamResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var output: Idb_VideoStreamResponse.OneOf_Output? = nil

  var logOutput: Data {
    get {
      if case .logOutput(let v)? = output {return v}
      return Data()
    }
    set {output = .logOutput(newValue)}
  }

  var payload: Idb_Payload {
    get {
      if case .payload(let v)? = output {return v}
      return Idb_Payload()
    }
    set {output = .payload(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Output: Equatable, @unchecked Sendable {
    case logOutput(Data)
    case payload(Idb_Payload)

  }

  init() {}
}

struct Idb_LaunchRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var control: Idb_LaunchRequest.OneOf_Control? = nil

  var start: Idb_LaunchRequest.Start {
    get {
      if case .start(let v)? = control {return v}
      return Idb_LaunchRequest.Start()
    }
    set {control = .start(newValue)}
  }

  var stop: Idb_LaunchRequest.Stop {
    get {
      if case .stop(let v)? = control {return v}
      return Idb_LaunchRequest.Stop()
    }
    set {control = .stop(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Control: Equatable, Sendable {
    case start(Idb_LaunchRequest.Start)
    case stop(Idb_LaunchRequest.Stop)

  }

  struct Start: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bundleID: String = String()

    var env: Dictionary<String,String> = [:]

    var appArgs: [String] = []

    var foregroundIfRunning: Bool = false

    var waitFor: Bool = false

    var waitForDebugger: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Stop: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_LaunchResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var output: Idb_ProcessOutput {
    get {return _output ?? Idb_ProcessOutput()}
    set {_output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  var hasOutput: Bool {return self._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  mutating func clearOutput() {self._output = nil}

  var debugger: Idb_DebuggerInfo {
    get {return _debugger ?? Idb_DebuggerInfo()}
    set {_debugger = newValue}
  }
  /// Returns true if `debugger` has been explicitly set.
  var hasDebugger: Bool {return self._debugger != nil}
  /// Clears the value of `debugger`. Subsequent reads from it will return its default value.
  mutating func clearDebugger() {self._debugger = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _output: Idb_ProcessOutput? = nil
  fileprivate var _debugger: Idb_DebuggerInfo? = nil
}

struct Idb_AddMediaRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Idb_Payload {
    get {return _payload ?? Idb_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Idb_Payload? = nil
}

struct Idb_AddMediaResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_InstrumentsRunRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var control: Idb_InstrumentsRunRequest.OneOf_Control? = nil

  var start: Idb_InstrumentsRunRequest.Start {
    get {
      if case .start(let v)? = control {return v}
      return Idb_InstrumentsRunRequest.Start()
    }
    set {control = .start(newValue)}
  }

  var stop: Idb_InstrumentsRunRequest.Stop {
    get {
      if case .stop(let v)? = control {return v}
      return Idb_InstrumentsRunRequest.Stop()
    }
    set {control = .stop(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Control: Equatable, Sendable {
    case start(Idb_InstrumentsRunRequest.Start)
    case stop(Idb_InstrumentsRunRequest.Stop)

  }

  struct InstrumentsTimings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var terminateTimeout: Double = 0

    var launchRetryTimeout: Double = 0

    var launchErrorTimeout: Double = 0

    var operationDuration: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Start: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var templateName: String = String()

    var appBundleID: String = String()

    var environment: Dictionary<String,String> = [:]

    var arguments: [String] = []

    var timings: Idb_InstrumentsRunRequest.InstrumentsTimings {
      get {return _timings ?? Idb_InstrumentsRunRequest.InstrumentsTimings()}
      set {_timings = newValue}
    }
    /// Returns true if `timings` has been explicitly set.
    var hasTimings: Bool {return self._timings != nil}
    /// Clears the value of `timings`. Subsequent reads from it will return its default value.
    mutating func clearTimings() {self._timings = nil}

    var toolArguments: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timings: Idb_InstrumentsRunRequest.InstrumentsTimings? = nil
  }

  struct Stop: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var postProcessArguments: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_InstrumentsRunResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var output: Idb_InstrumentsRunResponse.OneOf_Output? = nil

  var logOutput: Data {
    get {
      if case .logOutput(let v)? = output {return v}
      return Data()
    }
    set {output = .logOutput(newValue)}
  }

  var payload: Idb_Payload {
    get {
      if case .payload(let v)? = output {return v}
      return Idb_Payload()
    }
    set {output = .payload(newValue)}
  }

  var state: Idb_InstrumentsRunResponse.State {
    get {
      if case .state(let v)? = output {return v}
      return .unknown
    }
    set {output = .state(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Output: Equatable, @unchecked Sendable {
    case logOutput(Data)
    case payload(Idb_Payload)
    case state(Idb_InstrumentsRunResponse.State)

  }

  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case runningInstruments // = 1
    case postProcessing // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .runningInstruments
      case 2: self = .postProcessing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .runningInstruments: return 1
      case .postProcessing: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_InstrumentsRunResponse.State] = [
      .unknown,
      .runningInstruments,
      .postProcessing,
    ]

  }

  init() {}
}

struct Idb_XctraceRecordRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var control: Idb_XctraceRecordRequest.OneOf_Control? = nil

  var start: Idb_XctraceRecordRequest.Start {
    get {
      if case .start(let v)? = control {return v}
      return Idb_XctraceRecordRequest.Start()
    }
    set {control = .start(newValue)}
  }

  var stop: Idb_XctraceRecordRequest.Stop {
    get {
      if case .stop(let v)? = control {return v}
      return Idb_XctraceRecordRequest.Stop()
    }
    set {control = .stop(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Control: Equatable, Sendable {
    case start(Idb_XctraceRecordRequest.Start)
    case stop(Idb_XctraceRecordRequest.Stop)

  }

  struct LauchProcess: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var processToLaunch: String = String()

    var launchArgs: [String] = []

    var targetStdin: String = String()

    var targetStdout: String = String()

    var processEnv: Dictionary<String,String> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Target: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var target: Idb_XctraceRecordRequest.Target.OneOf_Target? = nil

    var allProcesses: Bool {
      get {
        if case .allProcesses(let v)? = target {return v}
        return false
      }
      set {target = .allProcesses(newValue)}
    }

    var processToAttach: String {
      get {
        if case .processToAttach(let v)? = target {return v}
        return String()
      }
      set {target = .processToAttach(newValue)}
    }

    var launchProcess: Idb_XctraceRecordRequest.LauchProcess {
      get {
        if case .launchProcess(let v)? = target {return v}
        return Idb_XctraceRecordRequest.LauchProcess()
      }
      set {target = .launchProcess(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Target: Equatable, Sendable {
      case allProcesses(Bool)
      case processToAttach(String)
      case launchProcess(Idb_XctraceRecordRequest.LauchProcess)

    }

    init() {}
  }

  struct Start: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var templateName: String = String()

    var timeLimit: Double = 0

    var package: String = String()

    var target: Idb_XctraceRecordRequest.Target {
      get {return _target ?? Idb_XctraceRecordRequest.Target()}
      set {_target = newValue}
    }
    /// Returns true if `target` has been explicitly set.
    var hasTarget: Bool {return self._target != nil}
    /// Clears the value of `target`. Subsequent reads from it will return its default value.
    mutating func clearTarget() {self._target = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _target: Idb_XctraceRecordRequest.Target? = nil
  }

  struct Stop: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timeout: Double = 0

    var args: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_XctraceRecordResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var output: Idb_XctraceRecordResponse.OneOf_Output? = nil

  var log: Data {
    get {
      if case .log(let v)? = output {return v}
      return Data()
    }
    set {output = .log(newValue)}
  }

  var payload: Idb_Payload {
    get {
      if case .payload(let v)? = output {return v}
      return Idb_Payload()
    }
    set {output = .payload(newValue)}
  }

  var state: Idb_XctraceRecordResponse.State {
    get {
      if case .state(let v)? = output {return v}
      return .unknown
    }
    set {output = .state(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Output: Equatable, @unchecked Sendable {
    case log(Data)
    case payload(Idb_Payload)
    case state(Idb_XctraceRecordResponse.State)

  }

  enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case running // = 1
    case processing // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .running
      case 2: self = .processing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .running: return 1
      case .processing: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_XctraceRecordResponse.State] = [
      .unknown,
      .running,
      .processing,
    ]

  }

  init() {}
}

struct Idb_DebugServerRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var control: Idb_DebugServerRequest.OneOf_Control? = nil

  var start: Idb_DebugServerRequest.Start {
    get {
      if case .start(let v)? = control {return v}
      return Idb_DebugServerRequest.Start()
    }
    set {control = .start(newValue)}
  }

  var stop: Idb_DebugServerRequest.Stop {
    get {
      if case .stop(let v)? = control {return v}
      return Idb_DebugServerRequest.Stop()
    }
    set {control = .stop(newValue)}
  }

  var status: Idb_DebugServerRequest.Status {
    get {
      if case .status(let v)? = control {return v}
      return Idb_DebugServerRequest.Status()
    }
    set {control = .status(newValue)}
  }

  var pipe: Idb_DebugServerRequest.Pipe {
    get {
      if case .pipe(let v)? = control {return v}
      return Idb_DebugServerRequest.Pipe()
    }
    set {control = .pipe(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Control: Equatable, Sendable {
    case start(Idb_DebugServerRequest.Start)
    case stop(Idb_DebugServerRequest.Stop)
    case status(Idb_DebugServerRequest.Status)
    case pipe(Idb_DebugServerRequest.Pipe)

  }

  struct Start: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var bundleID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Status: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Stop: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Pipe: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_DebugServerResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var control: Idb_DebugServerResponse.OneOf_Control? = nil

  var status: Idb_DebugServerResponse.Status {
    get {
      if case .status(let v)? = control {return v}
      return Idb_DebugServerResponse.Status()
    }
    set {control = .status(newValue)}
  }

  var pipe: Idb_DebugServerResponse.Pipe {
    get {
      if case .pipe(let v)? = control {return v}
      return Idb_DebugServerResponse.Pipe()
    }
    set {control = .pipe(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Control: Equatable, Sendable {
    case status(Idb_DebugServerResponse.Status)
    case pipe(Idb_DebugServerResponse.Pipe)

  }

  struct Pipe: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Status: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var lldbBootstrapCommands: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_CrashShowRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_CrashLogResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var list: [Idb_CrashLogInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_CrashLogInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var bundleID: String = String()

  var processName: String = String()

  var parentProcessName: String = String()

  var processIdentifier: UInt64 = 0

  var parentProcessIdentifier: UInt64 = 0

  var timestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_CrashShowResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var info: Idb_CrashLogInfo {
    get {return _info ?? Idb_CrashLogInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var contents: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Idb_CrashLogInfo? = nil
}

struct Idb_CrashLogQuery: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var since: UInt64 = 0

  var before: UInt64 = 0

  var bundleID: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_XctestListBundlesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_XctestListBundlesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bundles: [Idb_XctestListBundlesResponse.Bundles] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Bundles: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String = String()

    var bundleID: String = String()

    var architectures: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_XctestListTestsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bundleName: String = String()

  var appPath: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_XctestListTestsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var names: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_XctestRunRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mode: Idb_XctestRunRequest.Mode {
    get {return _storage._mode ?? Idb_XctestRunRequest.Mode()}
    set {_uniqueStorage()._mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return _storage._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {_uniqueStorage()._mode = nil}

  var testBundleID: String {
    get {return _storage._testBundleID}
    set {_uniqueStorage()._testBundleID = newValue}
  }

  var testsToRun: [String] {
    get {return _storage._testsToRun}
    set {_uniqueStorage()._testsToRun = newValue}
  }

  var testsToSkip: [String] {
    get {return _storage._testsToSkip}
    set {_uniqueStorage()._testsToSkip = newValue}
  }

  var arguments: [String] {
    get {return _storage._arguments}
    set {_uniqueStorage()._arguments = newValue}
  }

  var environment: Dictionary<String,String> {
    get {return _storage._environment}
    set {_uniqueStorage()._environment = newValue}
  }

  var timeout: UInt64 {
    get {return _storage._timeout}
    set {_uniqueStorage()._timeout = newValue}
  }

  var reportActivities: Bool {
    get {return _storage._reportActivities}
    set {_uniqueStorage()._reportActivities = newValue}
  }

  var collectCoverage: Bool {
    get {return _storage._collectCoverage}
    set {_uniqueStorage()._collectCoverage = newValue}
  }

  var reportAttachments: Bool {
    get {return _storage._reportAttachments}
    set {_uniqueStorage()._reportAttachments = newValue}
  }

  var collectLogs: Bool {
    get {return _storage._collectLogs}
    set {_uniqueStorage()._collectLogs = newValue}
  }

  var waitForDebugger: Bool {
    get {return _storage._waitForDebugger}
    set {_uniqueStorage()._waitForDebugger = newValue}
  }

  var codeCoverage: Idb_XctestRunRequest.CodeCoverage {
    get {return _storage._codeCoverage ?? Idb_XctestRunRequest.CodeCoverage()}
    set {_uniqueStorage()._codeCoverage = newValue}
  }
  /// Returns true if `codeCoverage` has been explicitly set.
  var hasCodeCoverage: Bool {return _storage._codeCoverage != nil}
  /// Clears the value of `codeCoverage`. Subsequent reads from it will return its default value.
  mutating func clearCodeCoverage() {_uniqueStorage()._codeCoverage = nil}

  var collectResultBundle: Bool {
    get {return _storage._collectResultBundle}
    set {_uniqueStorage()._collectResultBundle = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Logic: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Application: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var appBundleID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UI: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var appBundleID: String = String()

    var testHostAppBundleID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Mode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mode: Idb_XctestRunRequest.Mode.OneOf_Mode? = nil

    var logic: Idb_XctestRunRequest.Logic {
      get {
        if case .logic(let v)? = mode {return v}
        return Idb_XctestRunRequest.Logic()
      }
      set {mode = .logic(newValue)}
    }

    var application: Idb_XctestRunRequest.Application {
      get {
        if case .application(let v)? = mode {return v}
        return Idb_XctestRunRequest.Application()
      }
      set {mode = .application(newValue)}
    }

    var ui: Idb_XctestRunRequest.UI {
      get {
        if case .ui(let v)? = mode {return v}
        return Idb_XctestRunRequest.UI()
      }
      set {mode = .ui(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Mode: Equatable, Sendable {
      case logic(Idb_XctestRunRequest.Logic)
      case application(Idb_XctestRunRequest.Application)
      case ui(Idb_XctestRunRequest.UI)

    }

    init() {}
  }

  struct CodeCoverage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var collect: Bool = false

    var format: Idb_XctestRunRequest.CodeCoverage.Format = .exported

    var enableContinuousCoverageCollection: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Format: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case exported // = 0
      case raw // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .exported
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .exported
        case 1: self = .raw
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .exported: return 0
        case .raw: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Idb_XctestRunRequest.CodeCoverage.Format] = [
        .exported,
        .raw,
      ]

    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Idb_XctestRunResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Idb_XctestRunResponse.Status = .running

  var results: [Idb_XctestRunResponse.TestRunInfo] = []

  var logOutput: [String] = []

  var resultBundle: Idb_Payload {
    get {return _resultBundle ?? Idb_Payload()}
    set {_resultBundle = newValue}
  }
  /// Returns true if `resultBundle` has been explicitly set.
  var hasResultBundle: Bool {return self._resultBundle != nil}
  /// Clears the value of `resultBundle`. Subsequent reads from it will return its default value.
  mutating func clearResultBundle() {self._resultBundle = nil}

  var coverageJson: String = String()

  var logDirectory: Idb_Payload {
    get {return _logDirectory ?? Idb_Payload()}
    set {_logDirectory = newValue}
  }
  /// Returns true if `logDirectory` has been explicitly set.
  var hasLogDirectory: Bool {return self._logDirectory != nil}
  /// Clears the value of `logDirectory`. Subsequent reads from it will return its default value.
  mutating func clearLogDirectory() {self._logDirectory = nil}

  var debugger: Idb_DebuggerInfo {
    get {return _debugger ?? Idb_DebuggerInfo()}
    set {_debugger = newValue}
  }
  /// Returns true if `debugger` has been explicitly set.
  var hasDebugger: Bool {return self._debugger != nil}
  /// Clears the value of `debugger`. Subsequent reads from it will return its default value.
  mutating func clearDebugger() {self._debugger = nil}

  var codeCoverageData: Idb_Payload {
    get {return _codeCoverageData ?? Idb_Payload()}
    set {_codeCoverageData = newValue}
  }
  /// Returns true if `codeCoverageData` has been explicitly set.
  var hasCodeCoverageData: Bool {return self._codeCoverageData != nil}
  /// Clears the value of `codeCoverageData`. Subsequent reads from it will return its default value.
  mutating func clearCodeCoverageData() {self._codeCoverageData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case running // = 0
    case terminatedNormally // = 1
    case terminatedAbnormally // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .running
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .running
      case 1: self = .terminatedNormally
      case 2: self = .terminatedAbnormally
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .running: return 0
      case .terminatedNormally: return 1
      case .terminatedAbnormally: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_XctestRunResponse.Status] = [
      .running,
      .terminatedNormally,
      .terminatedAbnormally,
    ]

  }

  struct TestRunInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var status: Idb_XctestRunResponse.TestRunInfo.Status = .passed

    var bundleName: String = String()

    var className: String = String()

    var methodName: String = String()

    var duration: Double = 0

    var failureInfo: Idb_XctestRunResponse.TestRunInfo.TestRunFailureInfo {
      get {return _failureInfo ?? Idb_XctestRunResponse.TestRunInfo.TestRunFailureInfo()}
      set {_failureInfo = newValue}
    }
    /// Returns true if `failureInfo` has been explicitly set.
    var hasFailureInfo: Bool {return self._failureInfo != nil}
    /// Clears the value of `failureInfo`. Subsequent reads from it will return its default value.
    mutating func clearFailureInfo() {self._failureInfo = nil}

    var logs: [String] = []

    var activityLogs: [Idb_XctestRunResponse.TestRunInfo.TestActivity] = []

    var otherFailures: [Idb_XctestRunResponse.TestRunInfo.TestRunFailureInfo] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case passed // = 0
      case failed // = 1
      case crashed // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .passed
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .passed
        case 1: self = .failed
        case 2: self = .crashed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .passed: return 0
        case .failed: return 1
        case .crashed: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [Idb_XctestRunResponse.TestRunInfo.Status] = [
        .passed,
        .failed,
        .crashed,
      ]

    }

    struct TestRunFailureInfo: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var failureMessage: String = String()

      var file: String = String()

      var line: UInt64 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct TestAttachment: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var payload: Data = Data()

      var timestamp: Double = 0

      var name: String = String()

      var uniformTypeIdentifier: String = String()

      var userInfoJson: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct TestActivity: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var title: String = String()

      var duration: Double = 0

      var uuid: String = String()

      var activityType: String = String()

      var start: Double = 0

      var finish: Double = 0

      var name: String = String()

      var attachments: [Idb_XctestRunResponse.TestRunInfo.TestAttachment] = []

      var subActivities: [Idb_XctestRunResponse.TestRunInfo.TestActivity] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _failureInfo: Idb_XctestRunResponse.TestRunInfo.TestRunFailureInfo? = nil
  }

  init() {}

  fileprivate var _resultBundle: Idb_Payload? = nil
  fileprivate var _logDirectory: Idb_Payload? = nil
  fileprivate var _debugger: Idb_DebuggerInfo? = nil
  fileprivate var _codeCoverageData: Idb_Payload? = nil
}

struct Idb_FileContainer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Idb_FileContainer.Kind = .none

  var bundleID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Kind: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case none // = 0
    case application // = 1
    case root // = 2
    case media // = 3
    case crashes // = 4
    case provisioningProfiles // = 5
    case mdmProfiles // = 6
    case springboardIcons // = 7
    case wallpaper // = 8
    case diskImages // = 9
    case groupContainer // = 10
    case applicationContainer // = 11
    case auxillary // = 12
    case xctest // = 13
    case dylib // = 14
    case dsym // = 15
    case framework // = 16
    case symbols // = 17
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .application
      case 2: self = .root
      case 3: self = .media
      case 4: self = .crashes
      case 5: self = .provisioningProfiles
      case 6: self = .mdmProfiles
      case 7: self = .springboardIcons
      case 8: self = .wallpaper
      case 9: self = .diskImages
      case 10: self = .groupContainer
      case 11: self = .applicationContainer
      case 12: self = .auxillary
      case 13: self = .xctest
      case 14: self = .dylib
      case 15: self = .dsym
      case 16: self = .framework
      case 17: self = .symbols
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .application: return 1
      case .root: return 2
      case .media: return 3
      case .crashes: return 4
      case .provisioningProfiles: return 5
      case .mdmProfiles: return 6
      case .springboardIcons: return 7
      case .wallpaper: return 8
      case .diskImages: return 9
      case .groupContainer: return 10
      case .applicationContainer: return 11
      case .auxillary: return 12
      case .xctest: return 13
      case .dylib: return 14
      case .dsym: return 15
      case .framework: return 16
      case .symbols: return 17
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Idb_FileContainer.Kind] = [
      .none,
      .application,
      .root,
      .media,
      .crashes,
      .provisioningProfiles,
      .mdmProfiles,
      .springboardIcons,
      .wallpaper,
      .diskImages,
      .groupContainer,
      .applicationContainer,
      .auxillary,
      .xctest,
      .dylib,
      .dsym,
      .framework,
      .symbols,
    ]

  }

  init() {}
}

struct Idb_FileInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_FileListing: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parent: Idb_FileInfo {
    get {return _parent ?? Idb_FileInfo()}
    set {_parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  var hasParent: Bool {return self._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  mutating func clearParent() {self._parent = nil}

  var files: [Idb_FileInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _parent: Idb_FileInfo? = nil
}

struct Idb_LsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var files: [Idb_FileInfo] = []

  var listings: [Idb_FileListing] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_LsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var container: Idb_FileContainer {
    get {return _container ?? Idb_FileContainer()}
    set {_container = newValue}
  }
  /// Returns true if `container` has been explicitly set.
  var hasContainer: Bool {return self._container != nil}
  /// Clears the value of `container`. Subsequent reads from it will return its default value.
  mutating func clearContainer() {self._container = nil}

  var paths: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _container: Idb_FileContainer? = nil
}

struct Idb_MkdirRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var container: Idb_FileContainer {
    get {return _container ?? Idb_FileContainer()}
    set {_container = newValue}
  }
  /// Returns true if `container` has been explicitly set.
  var hasContainer: Bool {return self._container != nil}
  /// Clears the value of `container`. Subsequent reads from it will return its default value.
  mutating func clearContainer() {self._container = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _container: Idb_FileContainer? = nil
}

struct Idb_MkdirResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_MvRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var srcPaths: [String] = []

  var dstPath: String = String()

  var container: Idb_FileContainer {
    get {return _container ?? Idb_FileContainer()}
    set {_container = newValue}
  }
  /// Returns true if `container` has been explicitly set.
  var hasContainer: Bool {return self._container != nil}
  /// Clears the value of `container`. Subsequent reads from it will return its default value.
  mutating func clearContainer() {self._container = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _container: Idb_FileContainer? = nil
}

struct Idb_MvResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_RmRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paths: [String] = []

  var container: Idb_FileContainer {
    get {return _container ?? Idb_FileContainer()}
    set {_container = newValue}
  }
  /// Returns true if `container` has been explicitly set.
  var hasContainer: Bool {return self._container != nil}
  /// Clears the value of `container`. Subsequent reads from it will return its default value.
  mutating func clearContainer() {self._container = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _container: Idb_FileContainer? = nil
}

struct Idb_RmResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_PushRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Idb_PushRequest.OneOf_Value? = nil

  var payload: Idb_Payload {
    get {
      if case .payload(let v)? = value {return v}
      return Idb_Payload()
    }
    set {value = .payload(newValue)}
  }

  var inner: Idb_PushRequest.Inner {
    get {
      if case .inner(let v)? = value {return v}
      return Idb_PushRequest.Inner()
    }
    set {value = .inner(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable, Sendable {
    case payload(Idb_Payload)
    case inner(Idb_PushRequest.Inner)

  }

  struct Inner: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dstPath: String = String()

    var container: Idb_FileContainer {
      get {return _container ?? Idb_FileContainer()}
      set {_container = newValue}
    }
    /// Returns true if `container` has been explicitly set.
    var hasContainer: Bool {return self._container != nil}
    /// Clears the value of `container`. Subsequent reads from it will return its default value.
    mutating func clearContainer() {self._container = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _container: Idb_FileContainer? = nil
  }

  init() {}
}

struct Idb_PushResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_PullRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var srcPath: String = String()

  var dstPath: String = String()

  var container: Idb_FileContainer {
    get {return _container ?? Idb_FileContainer()}
    set {_container = newValue}
  }
  /// Returns true if `container` has been explicitly set.
  var hasContainer: Bool {return self._container != nil}
  /// Clears the value of `container`. Subsequent reads from it will return its default value.
  mutating func clearContainer() {self._container = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _container: Idb_FileContainer? = nil
}

struct Idb_PullResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Idb_Payload {
    get {return _payload ?? Idb_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Idb_Payload? = nil
}

struct Idb_TailRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var control: Idb_TailRequest.OneOf_Control? = nil

  var start: Idb_TailRequest.Start {
    get {
      if case .start(let v)? = control {return v}
      return Idb_TailRequest.Start()
    }
    set {control = .start(newValue)}
  }

  var stop: Idb_TailRequest.Stop {
    get {
      if case .stop(let v)? = control {return v}
      return Idb_TailRequest.Stop()
    }
    set {control = .stop(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Control: Equatable, Sendable {
    case start(Idb_TailRequest.Start)
    case stop(Idb_TailRequest.Stop)

  }

  struct Start: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var container: Idb_FileContainer {
      get {return _container ?? Idb_FileContainer()}
      set {_container = newValue}
    }
    /// Returns true if `container` has been explicitly set.
    var hasContainer: Bool {return self._container != nil}
    /// Clears the value of `container`. Subsequent reads from it will return its default value.
    mutating func clearContainer() {self._container = nil}

    var path: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _container: Idb_FileContainer? = nil
  }

  struct Stop: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_TailResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_DebuggerInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pid: UInt64 = 0

  var host: String = String()

  var port: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_SendNotificationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bundleID: String = String()

  var jsonPayload: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_SendNotificationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_DapRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var control: Idb_DapRequest.OneOf_Control? = nil

  var start: Idb_DapRequest.Start {
    get {
      if case .start(let v)? = control {return v}
      return Idb_DapRequest.Start()
    }
    set {control = .start(newValue)}
  }

  var pipe: Idb_DapRequest.Pipe {
    get {
      if case .pipe(let v)? = control {return v}
      return Idb_DapRequest.Pipe()
    }
    set {control = .pipe(newValue)}
  }

  var stop: Idb_DapRequest.Stop {
    get {
      if case .stop(let v)? = control {return v}
      return Idb_DapRequest.Stop()
    }
    set {control = .stop(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Control: Equatable, Sendable {
    case start(Idb_DapRequest.Start)
    case pipe(Idb_DapRequest.Pipe)
    case stop(Idb_DapRequest.Stop)

  }

  struct Start: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var debuggerPkgID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Pipe: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Stop: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_DapResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Idb_DapResponse.OneOf_Event? = nil

  var started: Idb_DapResponse.Event {
    get {
      if case .started(let v)? = event {return v}
      return Idb_DapResponse.Event()
    }
    set {event = .started(newValue)}
  }

  var stdout: Idb_DapResponse.Pipe {
    get {
      if case .stdout(let v)? = event {return v}
      return Idb_DapResponse.Pipe()
    }
    set {event = .stdout(newValue)}
  }

  var stopped: Idb_DapResponse.Event {
    get {
      if case .stopped(let v)? = event {return v}
      return Idb_DapResponse.Event()
    }
    set {event = .stopped(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable, Sendable {
    case started(Idb_DapResponse.Event)
    case stdout(Idb_DapResponse.Pipe)
    case stopped(Idb_DapResponse.Event)

  }

  struct Event: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var desc: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Pipe: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Idb_SimulateMemoryWarningRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Idb_SimulateMemoryWarningResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "idb"

extension Idb_Setting: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOCALE"),
    1: .same(proto: "ANY"),
  ]
}

extension Idb_Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_path"),
    2: .same(proto: "data"),
    3: .same(proto: "url"),
    4: .same(proto: "compression"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.source != nil {try decoder.handleConflictingOneOf()}
          self.source = .filePath(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.source != nil {try decoder.handleConflictingOneOf()}
          self.source = .data(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.source != nil {try decoder.handleConflictingOneOf()}
          self.source = .url(v)
        }
      }()
      case 4: try {
        var v: Idb_Payload.Compression?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.source != nil {try decoder.handleConflictingOneOf()}
          self.source = .compression(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.source {
    case .filePath?: try {
      guard case .filePath(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .url?: try {
      guard case .url(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .compression?: try {
      guard case .compression(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_Payload, rhs: Idb_Payload) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_Payload.Compression: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GZIP"),
    1: .same(proto: "ZSTD"),
  ]
}

extension Idb_ProcessOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProcessOutput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interface"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.interface) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.interface != .stdout {
      try visitor.visitSingularEnumField(value: self.interface, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ProcessOutput, rhs: Idb_ProcessOutput) -> Bool {
    if lhs.interface != rhs.interface {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ProcessOutput.Interface: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STDOUT"),
    1: .same(proto: "STDERR"),
  ]
}

extension Idb_CompanionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompanionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "udid"),
    4: .standard(proto: "is_local"),
    6: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.udid) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isLocal) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.udid.isEmpty {
      try visitor.visitSingularStringField(value: self.udid, fieldNumber: 1)
    }
    if self.isLocal != false {
      try visitor.visitSingularBoolField(value: self.isLocal, fieldNumber: 4)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_CompanionInfo, rhs: Idb_CompanionInfo) -> Bool {
    if lhs.udid != rhs.udid {return false}
    if lhs.isLocal != rhs.isLocal {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_SettingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SettingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hardwareKeyboard"),
    2: .same(proto: "stringSetting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_SettingRequest.HardwareKeyboard?
        var hadOneofValue = false
        if let current = self.setting {
          hadOneofValue = true
          if case .hardwareKeyboard(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.setting = .hardwareKeyboard(v)
        }
      }()
      case 2: try {
        var v: Idb_SettingRequest.StringSetting?
        var hadOneofValue = false
        if let current = self.setting {
          hadOneofValue = true
          if case .stringSetting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.setting = .stringSetting(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.setting {
    case .hardwareKeyboard?: try {
      guard case .hardwareKeyboard(let v)? = self.setting else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stringSetting?: try {
      guard case .stringSetting(let v)? = self.setting else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_SettingRequest, rhs: Idb_SettingRequest) -> Bool {
    if lhs.setting != rhs.setting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_SettingRequest.HardwareKeyboard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_SettingRequest.protoMessageName + ".HardwareKeyboard"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_SettingRequest.HardwareKeyboard, rhs: Idb_SettingRequest.HardwareKeyboard) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_SettingRequest.StringSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_SettingRequest.protoMessageName + ".StringSetting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "setting"),
    2: .same(proto: "value"),
    3: .same(proto: "name"),
    4: .same(proto: "domain"),
    5: .standard(proto: "value_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.setting) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.valueType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.setting != .locale {
      try visitor.visitSingularEnumField(value: self.setting, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 4)
    }
    if !self.valueType.isEmpty {
      try visitor.visitSingularStringField(value: self.valueType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_SettingRequest.StringSetting, rhs: Idb_SettingRequest.StringSetting) -> Bool {
    if lhs.setting != rhs.setting {return false}
    if lhs.value != rhs.value {return false}
    if lhs.name != rhs.name {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.valueType != rhs.valueType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_SettingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SettingResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_SettingResponse, rhs: Idb_SettingResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_GetSettingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSettingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "setting"),
    2: .same(proto: "name"),
    3: .same(proto: "domain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.setting) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.setting != .locale {
      try visitor.visitSingularEnumField(value: self.setting, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_GetSettingRequest, rhs: Idb_GetSettingRequest) -> Bool {
    if lhs.setting != rhs.setting {return false}
    if lhs.name != rhs.name {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_GetSettingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSettingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_GetSettingResponse, rhs: Idb_GetSettingResponse) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ListSettingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSettingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "setting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.setting) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.setting != .locale {
      try visitor.visitSingularEnumField(value: self.setting, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ListSettingRequest, rhs: Idb_ListSettingRequest) -> Bool {
    if lhs.setting != rhs.setting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ListSettingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSettingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ListSettingResponse, rhs: Idb_ListSettingResponse) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ListAppsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAppsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "suppress_process_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.suppressProcessState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.suppressProcessState != false {
      try visitor.visitSingularBoolField(value: self.suppressProcessState, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ListAppsRequest, rhs: Idb_ListAppsRequest) -> Bool {
    if lhs.suppressProcessState != rhs.suppressProcessState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ListAppsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListAppsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "apps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.apps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.apps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ListAppsResponse, rhs: Idb_ListAppsResponse) -> Bool {
    if lhs.apps != rhs.apps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_InstalledAppInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstalledAppInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_id"),
    2: .same(proto: "name"),
    3: .same(proto: "architectures"),
    4: .standard(proto: "install_type"),
    5: .standard(proto: "process_state"),
    6: .same(proto: "debuggable"),
    7: .standard(proto: "process_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.architectures) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.installType) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.processState) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.debuggable) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.processIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.architectures.isEmpty {
      try visitor.visitRepeatedStringField(value: self.architectures, fieldNumber: 3)
    }
    if !self.installType.isEmpty {
      try visitor.visitSingularStringField(value: self.installType, fieldNumber: 4)
    }
    if self.processState != .unknown {
      try visitor.visitSingularEnumField(value: self.processState, fieldNumber: 5)
    }
    if self.debuggable != false {
      try visitor.visitSingularBoolField(value: self.debuggable, fieldNumber: 6)
    }
    if self.processIdentifier != 0 {
      try visitor.visitSingularUInt64Field(value: self.processIdentifier, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_InstalledAppInfo, rhs: Idb_InstalledAppInfo) -> Bool {
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.architectures != rhs.architectures {return false}
    if lhs.installType != rhs.installType {return false}
    if lhs.processState != rhs.processState {return false}
    if lhs.debuggable != rhs.debuggable {return false}
    if lhs.processIdentifier != rhs.processIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_InstalledAppInfo.AppProcessState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NOT_RUNNING"),
    2: .same(proto: "RUNNING"),
  ]
}

extension Idb_InstallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstallRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .same(proto: "payload"),
    3: .standard(proto: "name_hint"),
    4: .standard(proto: "make_debuggable"),
    5: .standard(proto: "bundle_id"),
    6: .standard(proto: "link_dsym_to_bundle"),
    7: .standard(proto: "override_modification_time"),
    8: .standard(proto: "skip_signing_bundles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_InstallRequest.Destination?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .destination(v)
        }
      }()
      case 2: try {
        var v: Idb_Payload?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .payload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .payload(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .nameHint(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .makeDebuggable(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .bundleID(v)
        }
      }()
      case 6: try {
        var v: Idb_InstallRequest.LinkDsymToBundle?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .linkDsymToBundle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .linkDsymToBundle(v)
        }
      }()
      case 7: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .overrideModificationTime(v)
        }
      }()
      case 8: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .skipSigningBundles(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .destination?: try {
      guard case .destination(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .payload?: try {
      guard case .payload(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .nameHint?: try {
      guard case .nameHint(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .makeDebuggable?: try {
      guard case .makeDebuggable(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .bundleID?: try {
      guard case .bundleID(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .linkDsymToBundle?: try {
      guard case .linkDsymToBundle(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .overrideModificationTime?: try {
      guard case .overrideModificationTime(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }()
    case .skipSigningBundles?: try {
      guard case .skipSigningBundles(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_InstallRequest, rhs: Idb_InstallRequest) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_InstallRequest.Destination: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP"),
    1: .same(proto: "XCTEST"),
    2: .same(proto: "DYLIB"),
    3: .same(proto: "DSYM"),
    4: .same(proto: "FRAMEWORK"),
  ]
}

extension Idb_InstallRequest.LinkDsymToBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_InstallRequest.protoMessageName + ".LinkDsymToBundle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_type"),
    2: .standard(proto: "bundle_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.bundleType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bundleType != .app {
      try visitor.visitSingularEnumField(value: self.bundleType, fieldNumber: 1)
    }
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_InstallRequest.LinkDsymToBundle, rhs: Idb_InstallRequest.LinkDsymToBundle) -> Bool {
    if lhs.bundleType != rhs.bundleType {return false}
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_InstallRequest.LinkDsymToBundle.BundleType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP"),
    1: .same(proto: "XCTEST"),
  ]
}

extension Idb_InstallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstallResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "uuid"),
    3: .same(proto: "progress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.progress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 2)
    }
    if self.progress.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.progress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_InstallResponse, rhs: Idb_InstallResponse) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.progress != rhs.progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ScreenshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScreenshotRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ScreenshotRequest, rhs: Idb_ScreenshotRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ScreenshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScreenshotResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_data"),
    2: .standard(proto: "image_format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.imageData) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.imageFormat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imageData.isEmpty {
      try visitor.visitSingularBytesField(value: self.imageData, fieldNumber: 1)
    }
    if !self.imageFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.imageFormat, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ScreenshotResponse, rhs: Idb_ScreenshotResponse) -> Bool {
    if lhs.imageData != rhs.imageData {return false}
    if lhs.imageFormat != rhs.imageFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_FocusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FocusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_FocusRequest, rhs: Idb_FocusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_FocusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FocusResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_FocusResponse, rhs: Idb_FocusResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Point"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_Point, rhs: Idb_Point) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_AccessibilityInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessibilityInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "point"),
    3: .same(proto: "format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._point) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._point {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.format != .legacy {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_AccessibilityInfoRequest, rhs: Idb_AccessibilityInfoRequest) -> Bool {
    if lhs._point != rhs._point {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_AccessibilityInfoRequest.Format: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LEGACY"),
    1: .same(proto: "NESTED"),
  ]
}

extension Idb_AccessibilityInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessibilityInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "json"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.json) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.json.isEmpty {
      try visitor.visitSingularStringField(value: self.json, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_AccessibilityInfoResponse, rhs: Idb_AccessibilityInfoResponse) -> Bool {
    if lhs.json != rhs.json {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ApproveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApproveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_id"),
    2: .same(proto: "permissions"),
    3: .same(proto: "scheme"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.permissions) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scheme) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 1)
    }
    if !self.permissions.isEmpty {
      try visitor.visitPackedEnumField(value: self.permissions, fieldNumber: 2)
    }
    if !self.scheme.isEmpty {
      try visitor.visitSingularStringField(value: self.scheme, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ApproveRequest, rhs: Idb_ApproveRequest) -> Bool {
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.scheme != rhs.scheme {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ApproveRequest.Permission: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PHOTOS"),
    1: .same(proto: "CAMERA"),
    2: .same(proto: "CONTACTS"),
    3: .same(proto: "URL"),
    4: .same(proto: "LOCATION"),
    5: .same(proto: "NOTIFICATION"),
    6: .same(proto: "MICROPHONE"),
  ]
}

extension Idb_ApproveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ApproveResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ApproveResponse, rhs: Idb_ApproveResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_RevokeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_id"),
    2: .same(proto: "permissions"),
    3: .same(proto: "scheme"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.permissions) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.scheme) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 1)
    }
    if !self.permissions.isEmpty {
      try visitor.visitPackedEnumField(value: self.permissions, fieldNumber: 2)
    }
    if !self.scheme.isEmpty {
      try visitor.visitSingularStringField(value: self.scheme, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_RevokeRequest, rhs: Idb_RevokeRequest) -> Bool {
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.scheme != rhs.scheme {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_RevokeRequest.Permission: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PHOTOS"),
    1: .same(proto: "CAMERA"),
    2: .same(proto: "CONTACTS"),
    3: .same(proto: "URL"),
    4: .same(proto: "LOCATION"),
    5: .same(proto: "NOTIFICATION"),
    6: .same(proto: "MICROPHONE"),
  ]
}

extension Idb_RevokeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevokeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_RevokeResponse, rhs: Idb_RevokeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ClearKeychainRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClearKeychainRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ClearKeychainRequest, rhs: Idb_ClearKeychainRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ClearKeychainResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClearKeychainResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ClearKeychainResponse, rhs: Idb_ClearKeychainResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_SetLocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetLocationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_SetLocationRequest, rhs: Idb_SetLocationRequest) -> Bool {
    if lhs._location != rhs._location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 1)
    }
    if self.longitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_Location, rhs: Idb_Location) -> Bool {
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_SetLocationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetLocationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_SetLocationResponse, rhs: Idb_SetLocationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_UninstallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UninstallRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_UninstallRequest, rhs: Idb_UninstallRequest) -> Bool {
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_UninstallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UninstallResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_UninstallResponse, rhs: Idb_UninstallResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_TerminateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TerminateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_TerminateRequest, rhs: Idb_TerminateRequest) -> Bool {
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_TerminateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TerminateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_TerminateResponse, rhs: Idb_TerminateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_OpenUrlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenUrlRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_OpenUrlRequest, rhs: Idb_OpenUrlRequest) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_OpenUrlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpenUrlResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_OpenUrlResponse, rhs: Idb_OpenUrlResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ContactsUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactsUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ContactsUpdateRequest, rhs: Idb_ContactsUpdateRequest) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ContactsUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactsUpdateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ContactsUpdateResponse, rhs: Idb_ContactsUpdateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_TargetDescriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TargetDescriptionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fetch_diagnostics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.fetchDiagnostics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fetchDiagnostics != false {
      try visitor.visitSingularBoolField(value: self.fetchDiagnostics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_TargetDescriptionRequest, rhs: Idb_TargetDescriptionRequest) -> Bool {
    if lhs.fetchDiagnostics != rhs.fetchDiagnostics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_TargetDescriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TargetDescriptionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_description"),
    2: .same(proto: "companion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._targetDescription) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._companion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._targetDescription {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._companion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_TargetDescriptionResponse, rhs: Idb_TargetDescriptionResponse) -> Bool {
    if lhs._targetDescription != rhs._targetDescription {return false}
    if lhs._companion != rhs._companion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_HIDEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HIDEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "press"),
    2: .same(proto: "swipe"),
    3: .same(proto: "delay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_HIDEvent.HIDPress?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .press(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .press(v)
        }
      }()
      case 2: try {
        var v: Idb_HIDEvent.HIDSwipe?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .swipe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .swipe(v)
        }
      }()
      case 3: try {
        var v: Idb_HIDEvent.HIDDelay?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .delay(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .delay(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .press?: try {
      guard case .press(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .swipe?: try {
      guard case .swipe(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .delay?: try {
      guard case .delay(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_HIDEvent, rhs: Idb_HIDEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_HIDEvent.HIDDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DOWN"),
    1: .same(proto: "UP"),
  ]
}

extension Idb_HIDEvent.HIDButtonType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APPLE_PAY"),
    1: .same(proto: "HOME"),
    2: .same(proto: "LOCK"),
    3: .same(proto: "SIDE_BUTTON"),
    4: .same(proto: "SIRI"),
  ]
}

extension Idb_HIDEvent.HIDTouch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_HIDEvent.protoMessageName + ".HIDTouch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._point) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._point {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_HIDEvent.HIDTouch, rhs: Idb_HIDEvent.HIDTouch) -> Bool {
    if lhs._point != rhs._point {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_HIDEvent.HIDButton: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_HIDEvent.protoMessageName + ".HIDButton"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "button"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.button) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.button != .applePay {
      try visitor.visitSingularEnumField(value: self.button, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_HIDEvent.HIDButton, rhs: Idb_HIDEvent.HIDButton) -> Bool {
    if lhs.button != rhs.button {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_HIDEvent.HIDKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_HIDEvent.protoMessageName + ".HIDKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keycode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.keycode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keycode != 0 {
      try visitor.visitSingularUInt64Field(value: self.keycode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_HIDEvent.HIDKey, rhs: Idb_HIDEvent.HIDKey) -> Bool {
    if lhs.keycode != rhs.keycode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_HIDEvent.HIDPressAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_HIDEvent.protoMessageName + ".HIDPressAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "touch"),
    2: .same(proto: "button"),
    3: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_HIDEvent.HIDTouch?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .touch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .touch(v)
        }
      }()
      case 2: try {
        var v: Idb_HIDEvent.HIDButton?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .button(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .button(v)
        }
      }()
      case 3: try {
        var v: Idb_HIDEvent.HIDKey?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .key(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .key(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.action {
    case .touch?: try {
      guard case .touch(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .button?: try {
      guard case .button(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .key?: try {
      guard case .key(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_HIDEvent.HIDPressAction, rhs: Idb_HIDEvent.HIDPressAction) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_HIDEvent.HIDPress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_HIDEvent.protoMessageName + ".HIDPress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "direction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.direction != .down {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_HIDEvent.HIDPress, rhs: Idb_HIDEvent.HIDPress) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_HIDEvent.HIDSwipe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_HIDEvent.protoMessageName + ".HIDSwipe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
    5: .same(proto: "delta"),
    6: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.delta) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.delta.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.delta, fieldNumber: 5)
    }
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_HIDEvent.HIDSwipe, rhs: Idb_HIDEvent.HIDSwipe) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.delta != rhs.delta {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_HIDEvent.HIDDelay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_HIDEvent.protoMessageName + ".HIDDelay"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_HIDEvent.HIDDelay, rhs: Idb_HIDEvent.HIDDelay) -> Bool {
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_HIDResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HIDResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_HIDResponse, rhs: Idb_HIDResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    4: .standard(proto: "local_file_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.localFilePath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 1)
    }
    if !self.localFilePath.isEmpty {
      try visitor.visitSingularStringField(value: self.localFilePath, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ConnectRequest, rhs: Idb_ConnectRequest) -> Bool {
    if lhs.metadata != rhs.metadata {return false}
    if lhs.localFilePath != rhs.localFilePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "companion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._companion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._companion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ConnectResponse, rhs: Idb_ConnectResponse) -> Bool {
    if lhs._companion != rhs._companion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_ScreenDimensions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScreenDimensions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "density"),
    4: .standard(proto: "width_points"),
    5: .standard(proto: "height_points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.density) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.widthPoints) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.heightPoints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularUInt64Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 2)
    }
    if self.density.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.density, fieldNumber: 3)
    }
    if self.widthPoints != 0 {
      try visitor.visitSingularUInt64Field(value: self.widthPoints, fieldNumber: 4)
    }
    if self.heightPoints != 0 {
      try visitor.visitSingularUInt64Field(value: self.heightPoints, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_ScreenDimensions, rhs: Idb_ScreenDimensions) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.density != rhs.density {return false}
    if lhs.widthPoints != rhs.widthPoints {return false}
    if lhs.heightPoints != rhs.heightPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_TargetDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TargetDescription"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "udid"),
    2: .same(proto: "name"),
    3: .standard(proto: "screen_dimensions"),
    4: .same(proto: "state"),
    5: .standard(proto: "target_type"),
    6: .standard(proto: "os_version"),
    7: .same(proto: "architecture"),
    9: .same(proto: "extended"),
    10: .same(proto: "diagnostics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.udid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._screenDimensions) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.targetType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.architecture) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.extended) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.diagnostics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.udid.isEmpty {
      try visitor.visitSingularStringField(value: self.udid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._screenDimensions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 4)
    }
    if !self.targetType.isEmpty {
      try visitor.visitSingularStringField(value: self.targetType, fieldNumber: 5)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 6)
    }
    if !self.architecture.isEmpty {
      try visitor.visitSingularStringField(value: self.architecture, fieldNumber: 7)
    }
    if !self.extended.isEmpty {
      try visitor.visitSingularBytesField(value: self.extended, fieldNumber: 9)
    }
    if !self.diagnostics.isEmpty {
      try visitor.visitSingularBytesField(value: self.diagnostics, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_TargetDescription, rhs: Idb_TargetDescription) -> Bool {
    if lhs.udid != rhs.udid {return false}
    if lhs.name != rhs.name {return false}
    if lhs._screenDimensions != rhs._screenDimensions {return false}
    if lhs.state != rhs.state {return false}
    if lhs.targetType != rhs.targetType {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.architecture != rhs.architecture {return false}
    if lhs.extended != rhs.extended {return false}
    if lhs.diagnostics != rhs.diagnostics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_LogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "arguments"),
    2: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.arguments) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.arguments, fieldNumber: 1)
    }
    if self.source != .target {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_LogRequest, rhs: Idb_LogRequest) -> Bool {
    if lhs.arguments != rhs.arguments {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_LogRequest.Source: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TARGET"),
    1: .same(proto: "COMPANION"),
  ]
}

extension Idb_LogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "output"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.output) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.output.isEmpty {
      try visitor.visitSingularBytesField(value: self.output, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_LogResponse, rhs: Idb_LogResponse) -> Bool {
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_RecordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_RecordRequest.Start?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .start(v)
        }
      }()
      case 2: try {
        var v: Idb_RecordRequest.Stop?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .stop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.control {
    case .start?: try {
      guard case .start(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_RecordRequest, rhs: Idb_RecordRequest) -> Bool {
    if lhs.control != rhs.control {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_RecordRequest.Start: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_RecordRequest.protoMessageName + ".Start"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_RecordRequest.Start, rhs: Idb_RecordRequest.Start) -> Bool {
    if lhs.filePath != rhs.filePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_RecordRequest.Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_RecordRequest.protoMessageName + ".Stop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_RecordRequest.Stop, rhs: Idb_RecordRequest.Stop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_RecordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecordResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_output"),
    2: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.output != nil {try decoder.handleConflictingOneOf()}
          self.output = .logOutput(v)
        }
      }()
      case 2: try {
        var v: Idb_Payload?
        var hadOneofValue = false
        if let current = self.output {
          hadOneofValue = true
          if case .payload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.output = .payload(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.output {
    case .logOutput?: try {
      guard case .logOutput(let v)? = self.output else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .payload?: try {
      guard case .payload(let v)? = self.output else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_RecordResponse, rhs: Idb_RecordResponse) -> Bool {
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_VideoStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoStreamRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_VideoStreamRequest.Start?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .start(v)
        }
      }()
      case 2: try {
        var v: Idb_VideoStreamRequest.Stop?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .stop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.control {
    case .start?: try {
      guard case .start(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_VideoStreamRequest, rhs: Idb_VideoStreamRequest) -> Bool {
    if lhs.control != rhs.control {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_VideoStreamRequest.Format: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "H264"),
    1: .same(proto: "RBGA"),
    2: .same(proto: "MJPEG"),
    3: .same(proto: "MINICAP"),
    4: .same(proto: "I420"),
  ]
}

extension Idb_VideoStreamRequest.Start: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_VideoStreamRequest.protoMessageName + ".Start"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_path"),
    2: .same(proto: "fps"),
    3: .same(proto: "format"),
    4: .standard(proto: "compression_quality"),
    5: .standard(proto: "scale_factor"),
    6: .standard(proto: "avg_bitrate"),
    7: .standard(proto: "key_frame_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.fps) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.compressionQuality) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.scaleFactor) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.avgBitrate) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.keyFrameRate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 1)
    }
    if self.fps != 0 {
      try visitor.visitSingularUInt64Field(value: self.fps, fieldNumber: 2)
    }
    if self.format != .h264 {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 3)
    }
    if self.compressionQuality.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.compressionQuality, fieldNumber: 4)
    }
    if self.scaleFactor.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.scaleFactor, fieldNumber: 5)
    }
    if self.avgBitrate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.avgBitrate, fieldNumber: 6)
    }
    if self.keyFrameRate.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.keyFrameRate, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_VideoStreamRequest.Start, rhs: Idb_VideoStreamRequest.Start) -> Bool {
    if lhs.filePath != rhs.filePath {return false}
    if lhs.fps != rhs.fps {return false}
    if lhs.format != rhs.format {return false}
    if lhs.compressionQuality != rhs.compressionQuality {return false}
    if lhs.scaleFactor != rhs.scaleFactor {return false}
    if lhs.avgBitrate != rhs.avgBitrate {return false}
    if lhs.keyFrameRate != rhs.keyFrameRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_VideoStreamRequest.Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_VideoStreamRequest.protoMessageName + ".Stop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_VideoStreamRequest.Stop, rhs: Idb_VideoStreamRequest.Stop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_VideoStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VideoStreamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_output"),
    2: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.output != nil {try decoder.handleConflictingOneOf()}
          self.output = .logOutput(v)
        }
      }()
      case 2: try {
        var v: Idb_Payload?
        var hadOneofValue = false
        if let current = self.output {
          hadOneofValue = true
          if case .payload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.output = .payload(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.output {
    case .logOutput?: try {
      guard case .logOutput(let v)? = self.output else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .payload?: try {
      guard case .payload(let v)? = self.output else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_VideoStreamResponse, rhs: Idb_VideoStreamResponse) -> Bool {
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_LaunchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LaunchRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_LaunchRequest.Start?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .start(v)
        }
      }()
      case 2: try {
        var v: Idb_LaunchRequest.Stop?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .stop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.control {
    case .start?: try {
      guard case .start(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_LaunchRequest, rhs: Idb_LaunchRequest) -> Bool {
    if lhs.control != rhs.control {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_LaunchRequest.Start: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_LaunchRequest.protoMessageName + ".Start"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_id"),
    2: .same(proto: "env"),
    3: .standard(proto: "app_args"),
    4: .standard(proto: "foreground_if_running"),
    5: .standard(proto: "wait_for"),
    6: .standard(proto: "wait_for_debugger"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.env) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.appArgs) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.foregroundIfRunning) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.waitFor) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.waitForDebugger) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 1)
    }
    if !self.env.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.env, fieldNumber: 2)
    }
    if !self.appArgs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.appArgs, fieldNumber: 3)
    }
    if self.foregroundIfRunning != false {
      try visitor.visitSingularBoolField(value: self.foregroundIfRunning, fieldNumber: 4)
    }
    if self.waitFor != false {
      try visitor.visitSingularBoolField(value: self.waitFor, fieldNumber: 5)
    }
    if self.waitForDebugger != false {
      try visitor.visitSingularBoolField(value: self.waitForDebugger, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_LaunchRequest.Start, rhs: Idb_LaunchRequest.Start) -> Bool {
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.env != rhs.env {return false}
    if lhs.appArgs != rhs.appArgs {return false}
    if lhs.foregroundIfRunning != rhs.foregroundIfRunning {return false}
    if lhs.waitFor != rhs.waitFor {return false}
    if lhs.waitForDebugger != rhs.waitForDebugger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_LaunchRequest.Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_LaunchRequest.protoMessageName + ".Stop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_LaunchRequest.Stop, rhs: Idb_LaunchRequest.Stop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_LaunchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LaunchResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "output"),
    4: .same(proto: "debugger"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._output) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._debugger) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._debugger {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_LaunchResponse, rhs: Idb_LaunchResponse) -> Bool {
    if lhs._output != rhs._output {return false}
    if lhs._debugger != rhs._debugger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_AddMediaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddMediaRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_AddMediaRequest, rhs: Idb_AddMediaRequest) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_AddMediaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddMediaResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_AddMediaResponse, rhs: Idb_AddMediaResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_InstrumentsRunRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstrumentsRunRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_InstrumentsRunRequest.Start?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .start(v)
        }
      }()
      case 2: try {
        var v: Idb_InstrumentsRunRequest.Stop?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .stop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.control {
    case .start?: try {
      guard case .start(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_InstrumentsRunRequest, rhs: Idb_InstrumentsRunRequest) -> Bool {
    if lhs.control != rhs.control {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_InstrumentsRunRequest.InstrumentsTimings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_InstrumentsRunRequest.protoMessageName + ".InstrumentsTimings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "terminate_timeout"),
    2: .standard(proto: "launch_retry_timeout"),
    3: .standard(proto: "launch_error_timeout"),
    4: .standard(proto: "operation_duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.terminateTimeout) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.launchRetryTimeout) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.launchErrorTimeout) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.operationDuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.terminateTimeout.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.terminateTimeout, fieldNumber: 1)
    }
    if self.launchRetryTimeout.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.launchRetryTimeout, fieldNumber: 2)
    }
    if self.launchErrorTimeout.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.launchErrorTimeout, fieldNumber: 3)
    }
    if self.operationDuration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.operationDuration, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_InstrumentsRunRequest.InstrumentsTimings, rhs: Idb_InstrumentsRunRequest.InstrumentsTimings) -> Bool {
    if lhs.terminateTimeout != rhs.terminateTimeout {return false}
    if lhs.launchRetryTimeout != rhs.launchRetryTimeout {return false}
    if lhs.launchErrorTimeout != rhs.launchErrorTimeout {return false}
    if lhs.operationDuration != rhs.operationDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_InstrumentsRunRequest.Start: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_InstrumentsRunRequest.protoMessageName + ".Start"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "template_name"),
    3: .standard(proto: "app_bundle_id"),
    4: .same(proto: "environment"),
    5: .same(proto: "arguments"),
    6: .same(proto: "timings"),
    7: .standard(proto: "tool_arguments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.templateName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appBundleID) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.environment) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.arguments) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timings) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.toolArguments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.templateName.isEmpty {
      try visitor.visitSingularStringField(value: self.templateName, fieldNumber: 2)
    }
    if !self.appBundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.appBundleID, fieldNumber: 3)
    }
    if !self.environment.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.environment, fieldNumber: 4)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.arguments, fieldNumber: 5)
    }
    try { if let v = self._timings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.toolArguments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.toolArguments, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_InstrumentsRunRequest.Start, rhs: Idb_InstrumentsRunRequest.Start) -> Bool {
    if lhs.templateName != rhs.templateName {return false}
    if lhs.appBundleID != rhs.appBundleID {return false}
    if lhs.environment != rhs.environment {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs._timings != rhs._timings {return false}
    if lhs.toolArguments != rhs.toolArguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_InstrumentsRunRequest.Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_InstrumentsRunRequest.protoMessageName + ".Stop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "post_process_arguments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.postProcessArguments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.postProcessArguments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.postProcessArguments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_InstrumentsRunRequest.Stop, rhs: Idb_InstrumentsRunRequest.Stop) -> Bool {
    if lhs.postProcessArguments != rhs.postProcessArguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_InstrumentsRunResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InstrumentsRunResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_output"),
    2: .same(proto: "payload"),
    3: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.output != nil {try decoder.handleConflictingOneOf()}
          self.output = .logOutput(v)
        }
      }()
      case 2: try {
        var v: Idb_Payload?
        var hadOneofValue = false
        if let current = self.output {
          hadOneofValue = true
          if case .payload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.output = .payload(v)
        }
      }()
      case 3: try {
        var v: Idb_InstrumentsRunResponse.State?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.output != nil {try decoder.handleConflictingOneOf()}
          self.output = .state(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.output {
    case .logOutput?: try {
      guard case .logOutput(let v)? = self.output else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .payload?: try {
      guard case .payload(let v)? = self.output else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .state?: try {
      guard case .state(let v)? = self.output else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_InstrumentsRunResponse, rhs: Idb_InstrumentsRunResponse) -> Bool {
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_InstrumentsRunResponse.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "RUNNING_INSTRUMENTS"),
    2: .same(proto: "POST_PROCESSING"),
  ]
}

extension Idb_XctraceRecordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XctraceRecordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_XctraceRecordRequest.Start?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .start(v)
        }
      }()
      case 2: try {
        var v: Idb_XctraceRecordRequest.Stop?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .stop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.control {
    case .start?: try {
      guard case .start(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctraceRecordRequest, rhs: Idb_XctraceRecordRequest) -> Bool {
    if lhs.control != rhs.control {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctraceRecordRequest.LauchProcess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctraceRecordRequest.protoMessageName + ".LauchProcess"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "process_to_launch"),
    2: .standard(proto: "launch_args"),
    3: .standard(proto: "target_stdin"),
    4: .standard(proto: "target_stdout"),
    5: .standard(proto: "process_env"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.processToLaunch) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.launchArgs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetStdin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetStdout) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.processEnv) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.processToLaunch.isEmpty {
      try visitor.visitSingularStringField(value: self.processToLaunch, fieldNumber: 1)
    }
    if !self.launchArgs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.launchArgs, fieldNumber: 2)
    }
    if !self.targetStdin.isEmpty {
      try visitor.visitSingularStringField(value: self.targetStdin, fieldNumber: 3)
    }
    if !self.targetStdout.isEmpty {
      try visitor.visitSingularStringField(value: self.targetStdout, fieldNumber: 4)
    }
    if !self.processEnv.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.processEnv, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctraceRecordRequest.LauchProcess, rhs: Idb_XctraceRecordRequest.LauchProcess) -> Bool {
    if lhs.processToLaunch != rhs.processToLaunch {return false}
    if lhs.launchArgs != rhs.launchArgs {return false}
    if lhs.targetStdin != rhs.targetStdin {return false}
    if lhs.targetStdout != rhs.targetStdout {return false}
    if lhs.processEnv != rhs.processEnv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctraceRecordRequest.Target: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctraceRecordRequest.protoMessageName + ".Target"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "all_processes"),
    2: .standard(proto: "process_to_attach"),
    3: .standard(proto: "launch_process"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .allProcesses(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .processToAttach(v)
        }
      }()
      case 3: try {
        var v: Idb_XctraceRecordRequest.LauchProcess?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .launchProcess(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .launchProcess(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.target {
    case .allProcesses?: try {
      guard case .allProcesses(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .processToAttach?: try {
      guard case .processToAttach(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .launchProcess?: try {
      guard case .launchProcess(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctraceRecordRequest.Target, rhs: Idb_XctraceRecordRequest.Target) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctraceRecordRequest.Start: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctraceRecordRequest.protoMessageName + ".Start"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "template_name"),
    2: .standard(proto: "time_limit"),
    3: .same(proto: "package"),
    4: .same(proto: "target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.templateName) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.timeLimit) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.package) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.templateName.isEmpty {
      try visitor.visitSingularStringField(value: self.templateName, fieldNumber: 1)
    }
    if self.timeLimit.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timeLimit, fieldNumber: 2)
    }
    if !self.package.isEmpty {
      try visitor.visitSingularStringField(value: self.package, fieldNumber: 3)
    }
    try { if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctraceRecordRequest.Start, rhs: Idb_XctraceRecordRequest.Start) -> Bool {
    if lhs.templateName != rhs.templateName {return false}
    if lhs.timeLimit != rhs.timeLimit {return false}
    if lhs.package != rhs.package {return false}
    if lhs._target != rhs._target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctraceRecordRequest.Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctraceRecordRequest.protoMessageName + ".Stop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeout"),
    2: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.timeout) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeout.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timeout, fieldNumber: 1)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctraceRecordRequest.Stop, rhs: Idb_XctraceRecordRequest.Stop) -> Bool {
    if lhs.timeout != rhs.timeout {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctraceRecordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XctraceRecordResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "log"),
    2: .same(proto: "payload"),
    3: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.output != nil {try decoder.handleConflictingOneOf()}
          self.output = .log(v)
        }
      }()
      case 2: try {
        var v: Idb_Payload?
        var hadOneofValue = false
        if let current = self.output {
          hadOneofValue = true
          if case .payload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.output = .payload(v)
        }
      }()
      case 3: try {
        var v: Idb_XctraceRecordResponse.State?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.output != nil {try decoder.handleConflictingOneOf()}
          self.output = .state(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.output {
    case .log?: try {
      guard case .log(let v)? = self.output else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .payload?: try {
      guard case .payload(let v)? = self.output else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .state?: try {
      guard case .state(let v)? = self.output else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctraceRecordResponse, rhs: Idb_XctraceRecordResponse) -> Bool {
    if lhs.output != rhs.output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctraceRecordResponse.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "RUNNING"),
    2: .same(proto: "PROCESSING"),
  ]
}

extension Idb_DebugServerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugServerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "stop"),
    3: .same(proto: "status"),
    4: .same(proto: "pipe"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_DebugServerRequest.Start?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .start(v)
        }
      }()
      case 2: try {
        var v: Idb_DebugServerRequest.Stop?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .stop(v)
        }
      }()
      case 3: try {
        var v: Idb_DebugServerRequest.Status?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .status(v)
        }
      }()
      case 4: try {
        var v: Idb_DebugServerRequest.Pipe?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .pipe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .pipe(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.control {
    case .start?: try {
      guard case .start(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .status?: try {
      guard case .status(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .pipe?: try {
      guard case .pipe(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DebugServerRequest, rhs: Idb_DebugServerRequest) -> Bool {
    if lhs.control != rhs.control {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DebugServerRequest.Start: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_DebugServerRequest.protoMessageName + ".Start"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DebugServerRequest.Start, rhs: Idb_DebugServerRequest.Start) -> Bool {
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DebugServerRequest.Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_DebugServerRequest.protoMessageName + ".Status"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DebugServerRequest.Status, rhs: Idb_DebugServerRequest.Status) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DebugServerRequest.Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_DebugServerRequest.protoMessageName + ".Stop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DebugServerRequest.Stop, rhs: Idb_DebugServerRequest.Stop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DebugServerRequest.Pipe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_DebugServerRequest.protoMessageName + ".Pipe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DebugServerRequest.Pipe, rhs: Idb_DebugServerRequest.Pipe) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DebugServerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebugServerResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "pipe"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_DebugServerResponse.Status?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .status(v)
        }
      }()
      case 2: try {
        var v: Idb_DebugServerResponse.Pipe?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .pipe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .pipe(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.control {
    case .status?: try {
      guard case .status(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pipe?: try {
      guard case .pipe(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DebugServerResponse, rhs: Idb_DebugServerResponse) -> Bool {
    if lhs.control != rhs.control {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DebugServerResponse.Pipe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_DebugServerResponse.protoMessageName + ".Pipe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DebugServerResponse.Pipe, rhs: Idb_DebugServerResponse.Pipe) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DebugServerResponse.Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_DebugServerResponse.protoMessageName + ".Status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lldb_bootstrap_commands"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.lldbBootstrapCommands) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lldbBootstrapCommands.isEmpty {
      try visitor.visitRepeatedStringField(value: self.lldbBootstrapCommands, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DebugServerResponse.Status, rhs: Idb_DebugServerResponse.Status) -> Bool {
    if lhs.lldbBootstrapCommands != rhs.lldbBootstrapCommands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_CrashShowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CrashShowRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_CrashShowRequest, rhs: Idb_CrashShowRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_CrashLogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CrashLogResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_CrashLogResponse, rhs: Idb_CrashLogResponse) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_CrashLogInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CrashLogInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "bundle_id"),
    3: .standard(proto: "process_name"),
    4: .standard(proto: "parent_process_name"),
    5: .standard(proto: "process_identifier"),
    6: .standard(proto: "parent_process_identifier"),
    7: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.processName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.parentProcessName) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.processIdentifier) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.parentProcessIdentifier) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 2)
    }
    if !self.processName.isEmpty {
      try visitor.visitSingularStringField(value: self.processName, fieldNumber: 3)
    }
    if !self.parentProcessName.isEmpty {
      try visitor.visitSingularStringField(value: self.parentProcessName, fieldNumber: 4)
    }
    if self.processIdentifier != 0 {
      try visitor.visitSingularUInt64Field(value: self.processIdentifier, fieldNumber: 5)
    }
    if self.parentProcessIdentifier != 0 {
      try visitor.visitSingularUInt64Field(value: self.parentProcessIdentifier, fieldNumber: 6)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_CrashLogInfo, rhs: Idb_CrashLogInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.processName != rhs.processName {return false}
    if lhs.parentProcessName != rhs.parentProcessName {return false}
    if lhs.processIdentifier != rhs.processIdentifier {return false}
    if lhs.parentProcessIdentifier != rhs.parentProcessIdentifier {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_CrashShowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CrashShowResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .same(proto: "contents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.contents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.contents.isEmpty {
      try visitor.visitSingularStringField(value: self.contents, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_CrashShowResponse, rhs: Idb_CrashShowResponse) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.contents != rhs.contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_CrashLogQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CrashLogQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "since"),
    2: .same(proto: "before"),
    3: .standard(proto: "bundle_id"),
    4: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.since) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.before) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.since != 0 {
      try visitor.visitSingularUInt64Field(value: self.since, fieldNumber: 1)
    }
    if self.before != 0 {
      try visitor.visitSingularUInt64Field(value: self.before, fieldNumber: 2)
    }
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_CrashLogQuery, rhs: Idb_CrashLogQuery) -> Bool {
    if lhs.since != rhs.since {return false}
    if lhs.before != rhs.before {return false}
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestListBundlesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XctestListBundlesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestListBundlesRequest, rhs: Idb_XctestListBundlesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestListBundlesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XctestListBundlesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bundles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.bundles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bundles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestListBundlesResponse, rhs: Idb_XctestListBundlesResponse) -> Bool {
    if lhs.bundles != rhs.bundles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestListBundlesResponse.Bundles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctestListBundlesResponse.protoMessageName + ".Bundles"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "bundle_id"),
    3: .same(proto: "architectures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.architectures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 2)
    }
    if !self.architectures.isEmpty {
      try visitor.visitRepeatedStringField(value: self.architectures, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestListBundlesResponse.Bundles, rhs: Idb_XctestListBundlesResponse.Bundles) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.architectures != rhs.architectures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestListTestsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XctestListTestsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_name"),
    2: .standard(proto: "app_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleName.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleName, fieldNumber: 1)
    }
    if !self.appPath.isEmpty {
      try visitor.visitSingularStringField(value: self.appPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestListTestsRequest, rhs: Idb_XctestListTestsRequest) -> Bool {
    if lhs.bundleName != rhs.bundleName {return false}
    if lhs.appPath != rhs.appPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestListTestsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XctestListTestsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "names"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.names) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.names.isEmpty {
      try visitor.visitRepeatedStringField(value: self.names, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestListTestsResponse, rhs: Idb_XctestListTestsResponse) -> Bool {
    if lhs.names != rhs.names {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestRunRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XctestRunRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .standard(proto: "test_bundle_id"),
    3: .standard(proto: "tests_to_run"),
    4: .standard(proto: "tests_to_skip"),
    5: .same(proto: "arguments"),
    6: .same(proto: "environment"),
    7: .same(proto: "timeout"),
    8: .standard(proto: "report_activities"),
    9: .standard(proto: "collect_coverage"),
    10: .standard(proto: "report_attachments"),
    11: .standard(proto: "collect_logs"),
    12: .standard(proto: "wait_for_debugger"),
    13: .standard(proto: "code_coverage"),
    14: .standard(proto: "collect_result_bundle"),
  ]

  fileprivate class _StorageClass {
    var _mode: Idb_XctestRunRequest.Mode? = nil
    var _testBundleID: String = String()
    var _testsToRun: [String] = []
    var _testsToSkip: [String] = []
    var _arguments: [String] = []
    var _environment: Dictionary<String,String> = [:]
    var _timeout: UInt64 = 0
    var _reportActivities: Bool = false
    var _collectCoverage: Bool = false
    var _reportAttachments: Bool = false
    var _collectLogs: Bool = false
    var _waitForDebugger: Bool = false
    var _codeCoverage: Idb_XctestRunRequest.CodeCoverage? = nil
    var _collectResultBundle: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mode = source._mode
      _testBundleID = source._testBundleID
      _testsToRun = source._testsToRun
      _testsToSkip = source._testsToSkip
      _arguments = source._arguments
      _environment = source._environment
      _timeout = source._timeout
      _reportActivities = source._reportActivities
      _collectCoverage = source._collectCoverage
      _reportAttachments = source._reportAttachments
      _collectLogs = source._collectLogs
      _waitForDebugger = source._waitForDebugger
      _codeCoverage = source._codeCoverage
      _collectResultBundle = source._collectResultBundle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._mode) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._testBundleID) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._testsToRun) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._testsToSkip) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._arguments) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._environment) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeout) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._reportActivities) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._collectCoverage) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._reportAttachments) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._collectLogs) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._waitForDebugger) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._codeCoverage) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._collectResultBundle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._mode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._testBundleID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._testBundleID, fieldNumber: 2)
      }
      if !_storage._testsToRun.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._testsToRun, fieldNumber: 3)
      }
      if !_storage._testsToSkip.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._testsToSkip, fieldNumber: 4)
      }
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._arguments, fieldNumber: 5)
      }
      if !_storage._environment.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._environment, fieldNumber: 6)
      }
      if _storage._timeout != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timeout, fieldNumber: 7)
      }
      if _storage._reportActivities != false {
        try visitor.visitSingularBoolField(value: _storage._reportActivities, fieldNumber: 8)
      }
      if _storage._collectCoverage != false {
        try visitor.visitSingularBoolField(value: _storage._collectCoverage, fieldNumber: 9)
      }
      if _storage._reportAttachments != false {
        try visitor.visitSingularBoolField(value: _storage._reportAttachments, fieldNumber: 10)
      }
      if _storage._collectLogs != false {
        try visitor.visitSingularBoolField(value: _storage._collectLogs, fieldNumber: 11)
      }
      if _storage._waitForDebugger != false {
        try visitor.visitSingularBoolField(value: _storage._waitForDebugger, fieldNumber: 12)
      }
      try { if let v = _storage._codeCoverage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._collectResultBundle != false {
        try visitor.visitSingularBoolField(value: _storage._collectResultBundle, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestRunRequest, rhs: Idb_XctestRunRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._testBundleID != rhs_storage._testBundleID {return false}
        if _storage._testsToRun != rhs_storage._testsToRun {return false}
        if _storage._testsToSkip != rhs_storage._testsToSkip {return false}
        if _storage._arguments != rhs_storage._arguments {return false}
        if _storage._environment != rhs_storage._environment {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._reportActivities != rhs_storage._reportActivities {return false}
        if _storage._collectCoverage != rhs_storage._collectCoverage {return false}
        if _storage._reportAttachments != rhs_storage._reportAttachments {return false}
        if _storage._collectLogs != rhs_storage._collectLogs {return false}
        if _storage._waitForDebugger != rhs_storage._waitForDebugger {return false}
        if _storage._codeCoverage != rhs_storage._codeCoverage {return false}
        if _storage._collectResultBundle != rhs_storage._collectResultBundle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestRunRequest.Logic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctestRunRequest.protoMessageName + ".Logic"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestRunRequest.Logic, rhs: Idb_XctestRunRequest.Logic) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestRunRequest.Application: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctestRunRequest.protoMessageName + ".Application"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_bundle_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appBundleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appBundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.appBundleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestRunRequest.Application, rhs: Idb_XctestRunRequest.Application) -> Bool {
    if lhs.appBundleID != rhs.appBundleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestRunRequest.UI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctestRunRequest.protoMessageName + ".UI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_bundle_id"),
    2: .standard(proto: "test_host_app_bundle_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appBundleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.testHostAppBundleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appBundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.appBundleID, fieldNumber: 1)
    }
    if !self.testHostAppBundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.testHostAppBundleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestRunRequest.UI, rhs: Idb_XctestRunRequest.UI) -> Bool {
    if lhs.appBundleID != rhs.appBundleID {return false}
    if lhs.testHostAppBundleID != rhs.testHostAppBundleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestRunRequest.Mode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctestRunRequest.protoMessageName + ".Mode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "logic"),
    2: .same(proto: "application"),
    3: .same(proto: "ui"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_XctestRunRequest.Logic?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .logic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .logic(v)
        }
      }()
      case 2: try {
        var v: Idb_XctestRunRequest.Application?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .application(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .application(v)
        }
      }()
      case 3: try {
        var v: Idb_XctestRunRequest.UI?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .ui(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .ui(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.mode {
    case .logic?: try {
      guard case .logic(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .application?: try {
      guard case .application(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ui?: try {
      guard case .ui(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestRunRequest.Mode, rhs: Idb_XctestRunRequest.Mode) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestRunRequest.CodeCoverage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctestRunRequest.protoMessageName + ".CodeCoverage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collect"),
    2: .same(proto: "format"),
    3: .standard(proto: "enable_continuous_coverage_collection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.collect) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enableContinuousCoverageCollection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.collect != false {
      try visitor.visitSingularBoolField(value: self.collect, fieldNumber: 1)
    }
    if self.format != .exported {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 2)
    }
    if self.enableContinuousCoverageCollection != false {
      try visitor.visitSingularBoolField(value: self.enableContinuousCoverageCollection, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestRunRequest.CodeCoverage, rhs: Idb_XctestRunRequest.CodeCoverage) -> Bool {
    if lhs.collect != rhs.collect {return false}
    if lhs.format != rhs.format {return false}
    if lhs.enableContinuousCoverageCollection != rhs.enableContinuousCoverageCollection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestRunRequest.CodeCoverage.Format: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXPORTED"),
    1: .same(proto: "RAW"),
  ]
}

extension Idb_XctestRunResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XctestRunResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "results"),
    3: .standard(proto: "log_output"),
    4: .standard(proto: "result_bundle"),
    5: .standard(proto: "coverage_json"),
    6: .standard(proto: "log_directory"),
    7: .same(proto: "debugger"),
    8: .standard(proto: "code_coverage_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.logOutput) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._resultBundle) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.coverageJson) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._logDirectory) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._debugger) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._codeCoverageData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .running {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 2)
    }
    if !self.logOutput.isEmpty {
      try visitor.visitRepeatedStringField(value: self.logOutput, fieldNumber: 3)
    }
    try { if let v = self._resultBundle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.coverageJson.isEmpty {
      try visitor.visitSingularStringField(value: self.coverageJson, fieldNumber: 5)
    }
    try { if let v = self._logDirectory {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._debugger {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._codeCoverageData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestRunResponse, rhs: Idb_XctestRunResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.results != rhs.results {return false}
    if lhs.logOutput != rhs.logOutput {return false}
    if lhs._resultBundle != rhs._resultBundle {return false}
    if lhs.coverageJson != rhs.coverageJson {return false}
    if lhs._logDirectory != rhs._logDirectory {return false}
    if lhs._debugger != rhs._debugger {return false}
    if lhs._codeCoverageData != rhs._codeCoverageData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestRunResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RUNNING"),
    1: .same(proto: "TERMINATED_NORMALLY"),
    2: .same(proto: "TERMINATED_ABNORMALLY"),
  ]
}

extension Idb_XctestRunResponse.TestRunInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctestRunResponse.protoMessageName + ".TestRunInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "bundle_name"),
    3: .standard(proto: "class_name"),
    4: .standard(proto: "method_name"),
    5: .same(proto: "duration"),
    6: .standard(proto: "failure_info"),
    7: .same(proto: "logs"),
    8: .same(proto: "activityLogs"),
    9: .standard(proto: "other_failures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bundleName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.className) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._failureInfo) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.logs) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.activityLogs) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.otherFailures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .passed {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.bundleName.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleName, fieldNumber: 2)
    }
    if !self.className.isEmpty {
      try visitor.visitSingularStringField(value: self.className, fieldNumber: 3)
    }
    if !self.methodName.isEmpty {
      try visitor.visitSingularStringField(value: self.methodName, fieldNumber: 4)
    }
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 5)
    }
    try { if let v = self._failureInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.logs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.logs, fieldNumber: 7)
    }
    if !self.activityLogs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activityLogs, fieldNumber: 8)
    }
    if !self.otherFailures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.otherFailures, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestRunResponse.TestRunInfo, rhs: Idb_XctestRunResponse.TestRunInfo) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.bundleName != rhs.bundleName {return false}
    if lhs.className != rhs.className {return false}
    if lhs.methodName != rhs.methodName {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs._failureInfo != rhs._failureInfo {return false}
    if lhs.logs != rhs.logs {return false}
    if lhs.activityLogs != rhs.activityLogs {return false}
    if lhs.otherFailures != rhs.otherFailures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestRunResponse.TestRunInfo.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PASSED"),
    1: .same(proto: "FAILED"),
    2: .same(proto: "CRASHED"),
  ]
}

extension Idb_XctestRunResponse.TestRunInfo.TestRunFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctestRunResponse.TestRunInfo.protoMessageName + ".TestRunFailureInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "failure_message"),
    2: .same(proto: "file"),
    3: .same(proto: "line"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.failureMessage) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.file) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.line) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.failureMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.failureMessage, fieldNumber: 1)
    }
    if !self.file.isEmpty {
      try visitor.visitSingularStringField(value: self.file, fieldNumber: 2)
    }
    if self.line != 0 {
      try visitor.visitSingularUInt64Field(value: self.line, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestRunResponse.TestRunInfo.TestRunFailureInfo, rhs: Idb_XctestRunResponse.TestRunInfo.TestRunFailureInfo) -> Bool {
    if lhs.failureMessage != rhs.failureMessage {return false}
    if lhs.file != rhs.file {return false}
    if lhs.line != rhs.line {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestRunResponse.TestRunInfo.TestAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctestRunResponse.TestRunInfo.protoMessageName + ".TestAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "name"),
    4: .standard(proto: "uniform_type_identifier"),
    5: .standard(proto: "user_info_json"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniformTypeIdentifier) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.userInfoJson) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 1)
    }
    if self.timestamp.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timestamp, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniformTypeIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.uniformTypeIdentifier, fieldNumber: 4)
    }
    if !self.userInfoJson.isEmpty {
      try visitor.visitSingularBytesField(value: self.userInfoJson, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestRunResponse.TestRunInfo.TestAttachment, rhs: Idb_XctestRunResponse.TestRunInfo.TestAttachment) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniformTypeIdentifier != rhs.uniformTypeIdentifier {return false}
    if lhs.userInfoJson != rhs.userInfoJson {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_XctestRunResponse.TestRunInfo.TestActivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_XctestRunResponse.TestRunInfo.protoMessageName + ".TestActivity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "duration"),
    3: .same(proto: "uuid"),
    4: .standard(proto: "activity_type"),
    5: .same(proto: "start"),
    6: .same(proto: "finish"),
    7: .same(proto: "name"),
    8: .same(proto: "attachments"),
    9: .standard(proto: "sub_activities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.activityType) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.start) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.finish) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.subActivities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 2)
    }
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 3)
    }
    if !self.activityType.isEmpty {
      try visitor.visitSingularStringField(value: self.activityType, fieldNumber: 4)
    }
    if self.start.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.start, fieldNumber: 5)
    }
    if self.finish.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.finish, fieldNumber: 6)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 8)
    }
    if !self.subActivities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subActivities, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_XctestRunResponse.TestRunInfo.TestActivity, rhs: Idb_XctestRunResponse.TestRunInfo.TestActivity) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.uuid != rhs.uuid {return false}
    if lhs.activityType != rhs.activityType {return false}
    if lhs.start != rhs.start {return false}
    if lhs.finish != rhs.finish {return false}
    if lhs.name != rhs.name {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.subActivities != rhs.subActivities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_FileContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileContainer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .standard(proto: "bundle_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .none {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_FileContainer, rhs: Idb_FileContainer) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_FileContainer.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "APPLICATION"),
    2: .same(proto: "ROOT"),
    3: .same(proto: "MEDIA"),
    4: .same(proto: "CRASHES"),
    5: .same(proto: "PROVISIONING_PROFILES"),
    6: .same(proto: "MDM_PROFILES"),
    7: .same(proto: "SPRINGBOARD_ICONS"),
    8: .same(proto: "WALLPAPER"),
    9: .same(proto: "DISK_IMAGES"),
    10: .same(proto: "GROUP_CONTAINER"),
    11: .same(proto: "APPLICATION_CONTAINER"),
    12: .same(proto: "AUXILLARY"),
    13: .same(proto: "XCTEST"),
    14: .same(proto: "DYLIB"),
    15: .same(proto: "DSYM"),
    16: .same(proto: "FRAMEWORK"),
    17: .same(proto: "SYMBOLS"),
  ]
}

extension Idb_FileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_FileInfo, rhs: Idb_FileInfo) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_FileListing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileListing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "files"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parent) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_FileListing, rhs: Idb_FileListing) -> Bool {
    if lhs._parent != rhs._parent {return false}
    if lhs.files != rhs.files {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_LsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .same(proto: "listings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.listings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    if !self.listings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listings, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_LsResponse, rhs: Idb_LsResponse) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.listings != rhs.listings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_LsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "path"),
    3: .same(proto: "container"),
    4: .same(proto: "paths"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._container) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.paths) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try { if let v = self._container {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.paths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paths, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_LsRequest, rhs: Idb_LsRequest) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs._container != rhs._container {return false}
    if lhs.paths != rhs.paths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_MkdirRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MkdirRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "path"),
    3: .same(proto: "container"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._container) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try { if let v = self._container {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_MkdirRequest, rhs: Idb_MkdirRequest) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs._container != rhs._container {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_MkdirResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MkdirResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_MkdirResponse, rhs: Idb_MkdirResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_MvRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MvRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "src_paths"),
    3: .standard(proto: "dst_path"),
    4: .same(proto: "container"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.srcPaths) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dstPath) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._container) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.srcPaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.srcPaths, fieldNumber: 2)
    }
    if !self.dstPath.isEmpty {
      try visitor.visitSingularStringField(value: self.dstPath, fieldNumber: 3)
    }
    try { if let v = self._container {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_MvRequest, rhs: Idb_MvRequest) -> Bool {
    if lhs.srcPaths != rhs.srcPaths {return false}
    if lhs.dstPath != rhs.dstPath {return false}
    if lhs._container != rhs._container {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_MvResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MvResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_MvResponse, rhs: Idb_MvResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_RmRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RmRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "paths"),
    3: .same(proto: "container"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.paths) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._container) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.paths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paths, fieldNumber: 2)
    }
    try { if let v = self._container {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_RmRequest, rhs: Idb_RmRequest) -> Bool {
    if lhs.paths != rhs.paths {return false}
    if lhs._container != rhs._container {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_RmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RmResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_RmResponse, rhs: Idb_RmResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_PushRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PushRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "inner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_Payload?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .payload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .payload(v)
        }
      }()
      case 2: try {
        var v: Idb_PushRequest.Inner?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .inner(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .inner(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .payload?: try {
      guard case .payload(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .inner?: try {
      guard case .inner(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_PushRequest, rhs: Idb_PushRequest) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_PushRequest.Inner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_PushRequest.protoMessageName + ".Inner"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "dst_path"),
    3: .same(proto: "container"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.dstPath) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._container) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.dstPath.isEmpty {
      try visitor.visitSingularStringField(value: self.dstPath, fieldNumber: 2)
    }
    try { if let v = self._container {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_PushRequest.Inner, rhs: Idb_PushRequest.Inner) -> Bool {
    if lhs.dstPath != rhs.dstPath {return false}
    if lhs._container != rhs._container {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_PushResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PushResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_PushResponse, rhs: Idb_PushResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_PullRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PullRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "src_path"),
    3: .standard(proto: "dst_path"),
    4: .same(proto: "container"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.srcPath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dstPath) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._container) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.srcPath.isEmpty {
      try visitor.visitSingularStringField(value: self.srcPath, fieldNumber: 2)
    }
    if !self.dstPath.isEmpty {
      try visitor.visitSingularStringField(value: self.dstPath, fieldNumber: 3)
    }
    try { if let v = self._container {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_PullRequest, rhs: Idb_PullRequest) -> Bool {
    if lhs.srcPath != rhs.srcPath {return false}
    if lhs.dstPath != rhs.dstPath {return false}
    if lhs._container != rhs._container {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_PullResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PullResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_PullResponse, rhs: Idb_PullResponse) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_TailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TailRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_TailRequest.Start?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .start(v)
        }
      }()
      case 2: try {
        var v: Idb_TailRequest.Stop?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .stop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.control {
    case .start?: try {
      guard case .start(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_TailRequest, rhs: Idb_TailRequest) -> Bool {
    if lhs.control != rhs.control {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_TailRequest.Start: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_TailRequest.protoMessageName + ".Start"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "container"),
    2: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._container) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._container {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_TailRequest.Start, rhs: Idb_TailRequest.Start) -> Bool {
    if lhs._container != rhs._container {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_TailRequest.Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_TailRequest.protoMessageName + ".Stop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_TailRequest.Stop, rhs: Idb_TailRequest.Stop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_TailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TailResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_TailResponse, rhs: Idb_TailResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DebuggerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DebuggerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pid"),
    2: .same(proto: "host"),
    3: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.pid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pid != 0 {
      try visitor.visitSingularUInt64Field(value: self.pid, fieldNumber: 1)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 2)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt64Field(value: self.port, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DebuggerInfo, rhs: Idb_DebuggerInfo) -> Bool {
    if lhs.pid != rhs.pid {return false}
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_SendNotificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendNotificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bundle_id"),
    2: .standard(proto: "json_payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bundleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jsonPayload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bundleID.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleID, fieldNumber: 1)
    }
    if !self.jsonPayload.isEmpty {
      try visitor.visitSingularStringField(value: self.jsonPayload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_SendNotificationRequest, rhs: Idb_SendNotificationRequest) -> Bool {
    if lhs.bundleID != rhs.bundleID {return false}
    if lhs.jsonPayload != rhs.jsonPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_SendNotificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendNotificationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_SendNotificationResponse, rhs: Idb_SendNotificationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DapRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DapRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "pipe"),
    3: .same(proto: "stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_DapRequest.Start?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .start(v)
        }
      }()
      case 2: try {
        var v: Idb_DapRequest.Pipe?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .pipe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .pipe(v)
        }
      }()
      case 3: try {
        var v: Idb_DapRequest.Stop?
        var hadOneofValue = false
        if let current = self.control {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.control = .stop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.control {
    case .start?: try {
      guard case .start(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pipe?: try {
      guard case .pipe(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.control else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DapRequest, rhs: Idb_DapRequest) -> Bool {
    if lhs.control != rhs.control {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DapRequest.Start: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_DapRequest.protoMessageName + ".Start"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "debugger_pkg_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.debuggerPkgID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.debuggerPkgID.isEmpty {
      try visitor.visitSingularStringField(value: self.debuggerPkgID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DapRequest.Start, rhs: Idb_DapRequest.Start) -> Bool {
    if lhs.debuggerPkgID != rhs.debuggerPkgID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DapRequest.Pipe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_DapRequest.protoMessageName + ".Pipe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DapRequest.Pipe, rhs: Idb_DapRequest.Pipe) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DapRequest.Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_DapRequest.protoMessageName + ".Stop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DapRequest.Stop, rhs: Idb_DapRequest.Stop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DapResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DapResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "started"),
    2: .same(proto: "stdout"),
    3: .same(proto: "stopped"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Idb_DapResponse.Event?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .started(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .started(v)
        }
      }()
      case 2: try {
        var v: Idb_DapResponse.Pipe?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .stdout(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .stdout(v)
        }
      }()
      case 3: try {
        var v: Idb_DapResponse.Event?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .stopped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .stopped(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .started?: try {
      guard case .started(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .stdout?: try {
      guard case .stdout(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .stopped?: try {
      guard case .stopped(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DapResponse, rhs: Idb_DapResponse) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DapResponse.Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_DapResponse.protoMessageName + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "desc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.desc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.desc.isEmpty {
      try visitor.visitSingularStringField(value: self.desc, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DapResponse.Event, rhs: Idb_DapResponse.Event) -> Bool {
    if lhs.desc != rhs.desc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_DapResponse.Pipe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Idb_DapResponse.protoMessageName + ".Pipe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_DapResponse.Pipe, rhs: Idb_DapResponse.Pipe) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_SimulateMemoryWarningRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimulateMemoryWarningRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_SimulateMemoryWarningRequest, rhs: Idb_SimulateMemoryWarningRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Idb_SimulateMemoryWarningResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimulateMemoryWarningResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Idb_SimulateMemoryWarningResponse, rhs: Idb_SimulateMemoryWarningResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
